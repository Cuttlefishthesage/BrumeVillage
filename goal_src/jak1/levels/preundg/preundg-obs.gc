(deftype preundg-part (part-spawner) ())

(deftype preundg-maindoor (eco-door) ())


(defskelgroup *jng-iris-door-sg*
  jng-iris-door
  jng-iris-door-lod0-jg
  jng-iris-door-idle-ja
  ((jng-iris-door-lod0-mg (meters 999999)))
  :bounds (static-spherem 0 0 0 8))

(defmethod eco-door-method-24 ((this preundg-maindoor))
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum hit-by-others))))
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-kind wall-object))
      (set! (-> s4-0 collide-with) (collide-kind target))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set! (-> s4-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s4-0 transform-index) 0)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 16384.0)
      (set-root-prim! s5-0 s4-0))
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (backup-collide-with-as s5-0)
    (set! (-> this root) s5-0))
  0
  (none))

(defmethod eco-door-method-25 ((this preundg-maindoor))
  (initialize-skeleton this *jng-iris-door-sg* '())
  (set! (-> this open-distance) 22768.0)
  (set! (-> this close-distance) 23920.0)
  (set! (-> this auto-close) #t)
  (set! (-> this one-way) #t)
  (vector-z-quaternion! (-> this out-dir) (-> this root quat))
  (set! (-> this out-dir w) (- 8192.0 (vector-dot (-> this out-dir) (-> this root trans))))
  (update-transforms! (-> this root))
  0
  (none))


;;silodoor;;


(deftype preundg-silostep (process-drawable)
  ((anim-limit  float)
   (cam-tracker handle))
  (:states
   preundg-silostep-camera
   preundg-silostep-idle
   (preundg-silostep-rise symbol)))


(defskelgroup *silostep-sg*
  silostep
  silostep-lod0-jg
  silostep-idle-ja
  ((silostep-lod0-mg (meters 999999)))
  :bounds (static-spherem 0 2 0 8))

(defstate preundg-silostep-idle (preundg-silostep)
  :event
    (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
      (case message
        (('trigger) (go silostep-camera))
        (('trigger-rise) (go preundg-silostep-rise #f))))
  :code
    (behavior ()
      (ja :group! silostep-idle-ja :num! min)
      (transform-post)
      (loop
        (suspend)))
  :post ja-post)



(defstate preundg-silostep-camera (preundg-silostep)
  :code
    (behavior ()
      (misty-camera-view)
      (let* ((gp-0 (get-task-control (game-task misty-warehouse)))
             (v1-1 (get-reminder gp-0 0)))
        (save-reminder gp-0 (logior v1-1 2) 0))
      (set-time! (-> self state-time))
      (suspend-for (seconds 1))
      (sound-play "arena-steps")
      (send-to-all-after (-> self link) 'trigger-rise)
      (go preundg-silostep-rise #f))
  :post ja-post)

(defstate preundg-silostep-rise (preundg-silostep)
  :code
    (behavior ((arg0 symbol))
      (process-entity-status! self (entity-perm-status complete) #t)
      (when (not arg0)
        (ja-no-eval :group! silostep-idle-ja :num! (seek! (-> self anim-limit)) :frame-num 0.0)
        (until (ja-done? 0)
          (rider-trans)
          (rider-post)
          (suspend)
          (ja :num! (seek! (-> self anim-limit)))))
      (ja :group! silostep-idle-ja :num! (identity (-> self anim-limit)))
      (rider-post)
      (loop
        (ja-post)
        (suspend)))
  :post #f)

(defmethod init-from-entity! ((this preundg-silostep) (arg0 entity-actor))
  (logior! (-> this mask) (process-mask movie-subject))
  (let ((s4-0 (new 'process 'collide-shape-moving this (collide-list-enum hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) default-collision-reaction)
    (set! (-> s4-0 no-reaction) (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing))
    (alloc-riders s4-0 1)
    (let ((s3-0 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s3-0 prim-core collide-as) (collide-kind ground-object))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set! (-> s3-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s3-0 transform-index) 4)
      (set-vector! (-> s3-0 local-sphere) 0.0 4096.0 0.0 18432.0)
      (set-root-prim! s4-0 s3-0))
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> this root) s4-0))
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton this *silostep-sg* '())
  (set! (-> this anim-limit)
        (* (res-lump-float arg0 'distance :default 1.0)
           (the float (+ (-> (the-as art-joint-anim (-> this draw art-group data 2)) data 0 length) -1))))
  (set! (-> this link) (new 'process 'actor-link-info this))
  (if (and (-> this entity) (logtest? (-> this entity extra perm status) (entity-perm-status complete)))
    (go preundg-silostep-rise #t)
    (go preundg-silostep-idle))
  (none))


;;;;;gravityswitch (testing in mount, move to precursor underground);;;;;;;;;
(defpartgroup gravswitch
  :id 3107
  :bounds (static-bspherem 0 -12 0 14)
  :parts
  ((sp-item 3363 :fade-after (meters 60) :falloff-to (meters 60))
   (sp-item 3364 :fade-after (meters 160) :falloff-to (meters 160))))

(defpart 3363
  :init-specs
  ((:num 1.5)
   (:y (meters 1))
   (:rot-x 5)
   (:r 5324.8)
   (:g 4096.0)
   (:b 3686.4)
   (:vel-y (meters 0.0033333334))
   (:fade-b -16.383999)
   (:timer (seconds 0.085))
   (:flags (aux-list))
   (:conerot-x (degrees 140) (degrees 40))
   (:conerot-y (degrees 0) (degrees 360))
   (:conerot-radius (meters 3))))

(defpart 3364
  :init-specs
  ((:texture (hotdot effects))
   (:num 2.0)
   (:y (meters 1.5))
   (:scale-x (meters 2) (meters 1))
   (:scale-y :copy scale-x)
   (:g 0.0 64.0)
   (:b 128.0 128.0)
   (:a 16.0 32.0)
   (:vel-y (meters 0.01))
   (:fade-g -0.42666668)
   (:fade-a -0.32)
   (:accel-y (meters -0.000033333334))
   (:friction 0.96)
   (:timer (seconds 0.5))
   (:flags (bit2 bit3))
   (:conerot-x (degrees 130) (degrees 100.00001))
   (:conerot-y (degrees 0) (degrees 360))
   (:conerot-radius (meters 3))))


(defpart 3365
  :init-specs
  ((:texture (citadel-shield effects))
   (:birth-func 'birth-func-set-quat)
   (:num 1.0)
   (:scale-x (meters 0.5) (meters 0.1))
   (:scale-y (meters 5.0))
   (:r 0.0 0.0)
   (:g 0.0 0.0)
   (:b 128.0 32.0)
   (:a 128.0)
   (:timer (seconds 0.017))
   (:flags (bit2 bit3))))

;;================== SWITCH TYPE ==================;;

(deftype gravity-puzzle-switch (process-drawable)
  ((root        collide-shape-moving :override)
   (switch-id   uint)
   (birth-time  time-frame)
   (base        vector :inline)
   (old-base    vector :inline)
   (bob-offset  int64)
   (bob-amount  float))
  (:methods
   (init-collision! (_type_) none))
  (:states
   idle
   active))

(def-art-elt gravityswitch-ag gravityswitch-lod0-jg 0)
(def-art-elt gravityswitch-ag gravityswitch-lod0-mg 1)
(def-art-elt gravityswitch-ag gravityswitch-idle-ja 2)

(defskelgroup *gravityswitch-sg* gravityswitch gravityswitch-lod0-jg gravityswitch-idle-ja
              ((gravityswitch-lod0-mg (meters 9999999)))
              :bounds (static-spherem 0 0 0 5))

(def-actor gravity-switch        :bounds (0 0 0 5))
(def-actor gravity-puzzle-switch :bounds (0 0 0 5))
(def-actor gravity-puzzle-master :bounds (0 0 0 5))

(defmethod init-collision! ((this gravity-puzzle-switch))
  ;; Create the main collision shape for the actor
  (let ((cshape (new 'process 'collide-shape-moving this (collide-list-enum hit-by-player))))
    (set! (-> cshape dynam) (copy *standard-dynamics* 'process))
    (set! (-> cshape reaction) default-collision-reaction)
    (set! (-> cshape no-reaction)
          (the (function collide-shape-moving collide-shape-intersect vector vector none) nothing))
    
   
    (let ((cgroup (new 'process 'collide-shape-prim-group cshape (the uint 2) 0)))
      (set! (-> cgroup prim-core collide-as) (collide-kind ground-object))
      (set! (-> cgroup collide-with) (collide-kind target))
      (set! (-> cgroup prim-core action) (collide-action solid rider-plat-sticky))
      (set! (-> cgroup transform-index) 0)
      (set-vector! (-> cgroup local-sphere) 0.0 0.0 0.0 (meters 5))
      
      ;; Attach group as root
      (set-root-prim! cshape cgroup)

      ;; --- Sphere 1 (bottom) ---
      (let ((sphere (new 'process 'collide-shape-prim-sphere cshape (the uint 0))))
        (set! (-> sphere prim-core collide-as) (collide-kind enemy))
        (set! (-> sphere collide-with) (collide-kind target))
        (set! (-> sphere prim-core action) (collide-action solid))
        (set! (-> sphere prim-core offense) (collide-offense normal-attack))
        (set-vector! (-> sphere local-sphere) 0.0 0.0 0.0 (meters 2))
        (append-prim cgroup sphere))

      ;; --- Sphere 2 (offset above) ---
      (let ((sphere2 (new 'process 'collide-shape-prim-sphere cshape (the uint 0))))
        (set! (-> sphere2 prim-core collide-as) (collide-kind enemy))
        (set! (-> sphere2 collide-with) (collide-kind target))
        (set! (-> sphere2 prim-core action) (collide-action solid))
        (set! (-> sphere2 prim-core offense) (collide-offense normal-attack))
        (set-vector! (-> sphere2 local-sphere) 0.0 15000.0 0.0 (meters 2))
        (append-prim cgroup sphere2)))
    
    ;; Finish up
    (set! (-> cshape nav-radius) (* 0.75 (-> cshape root-prim local-sphere w)))
    (backup-collide-with-as cshape)
    (set! (-> this root) cshape))
  (none))

(defstate idle (gravity-puzzle-switch)
  :event
    (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
      (case message
        (('attack) ;; when jak hits, send a message to alt-actor of actors lump
         (format 0 "[SWITCH] Activated by ~A~%" proc)
         (let ((msg (new 'stack-no-clear 'event-message-block)))
           (set! (-> msg from) self)
           (set! (-> msg message) 'notify)
           (set! (-> msg num-params) 2)
           (set! (-> msg param 0) (the int (-> self switch-id)))
           (set! (-> msg param 1) 1)
           (format 0 "[SWITCH EVENT] self.switch-id=~D param0(before send)=~D~%"
                   (-> self switch-id) (the int (-> msg param 0)))
           (send-event-function (-> (entity-actor-lookup (-> self entity) 'alt-actor 0) extra process)
                                msg))
         (go active)
         #t)
        ((#t) #f)))
  :code
    (behavior ()
      (loop (suspend)))
  :post transform-post)


(defstate active (gravity-puzzle-switch)
  :event
    (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
      (case message
        
        ((#t) #f)))
  :trans
    (behavior ()


    (dotimes (i 1)
    (let ((pos (new 'stack-no-clear 'vector)))
      ;; copy root position
      (vector-copy! pos (-> self root trans))
      ;; add a fixed vertical offset
      (set! (-> pos y) (+ (-> pos y) (meters 3.0)))
      ;; add small random horizontal offset (±0.5m X/Z)
      (set! (-> pos x) (+ (-> pos x) (meters (* 0.05 (- (rand-vu-int-range 0 200) 100)))))
      (set! (-> pos z) (+ (-> pos z) (meters (* 0.05 (- (rand-vu-int-range 0 200) 100)))))

      ;; vert offset
      (set! (-> pos y) (+ (-> pos y)
                               (meters (* 3.0 (- (the float (rand-vu-int-range 0 200)) 100) 0.01))))

      ;; spawn the particle
      (launch-particles (-> *part-id-table* 260) pos)))


    (dotimes (i 3)
    (let ((pos (new 'stack-no-clear 'vector)))
      ;; copy root position
      (vector-copy! pos (-> self root trans))
      ;; add a fixed vertical offset
      (set! (-> pos y) (+ (-> pos y) (meters 4.0)))
      ;; add small random horizontal offset (±0.5m X/Z)
      (set! (-> pos x) (+ (-> pos x) (meters (* 0.01 (- (rand-vu-int-range 0 200) 100)))))
      (set! (-> pos z) (+ (-> pos z) (meters (* 0.01 (- (rand-vu-int-range 0 200) 100)))))

      (set! (-> pos y) (+ (-> pos y)
                               (meters (* 0.5 (- (the float (rand-vu-int-range 0 200)) 100) 0.01))))

      ;; spawn the particle
      (launch-particles (-> *part-id-table* 260) pos)))

    (let ((pos (new 'stack-no-clear 'vector)))
  (vector-copy! pos (-> self root trans))
  (set! (-> pos y) (+ (-> pos y) (meters 4.0))) 
  (launch-particles (-> *part-id-table* 3363) pos)
  (launch-particles (-> *part-id-table* 3364) pos)) ;; spawn particles at an offset from root

    (none)
    )
  :code
    (behavior ()
    (sound-play "eco-plat-hover")
      (loop
        (quaternion-rotate-y! (-> self root quat)
                              (-> self root quat)
                              (* (degrees 120) (seconds-per-frame))
                              )
      (let ((bob (-> self bob-amount)))
          (when (< 0.0 bob)
            (set! (-> self root trans y)
                  (+ (-> self base y)
                     (* bob
                        (sin (* 109.22667 (the float (mod (+ (- (current-time) (-> self birth-time)) (-> self bob-offset)) (seconds 2))))))))
            (update-transforms! (-> self root))))
        (suspend)))
  :post transform-post)

(defmethod init-from-entity! ((this gravity-puzzle-switch) (e entity-actor))
  (init-collision! this)
  (process-drawable-from-entity! this e)
  (set! (-> this base quad) (-> this root trans quad))
  (set! (-> this bob-amount) 1024.0)
  (set! (-> this bob-offset)
        (+ (the int (-> this root trans x)) (the int (-> this root trans y)) (the int (-> this root trans z))))
  (initialize-skeleton this *gravityswitch-sg* '())

  (let ((raw-id (res-lump-value (-> this entity) 'extra-id uint128
                                :default (the-as uint128 -1))))
    (if (>= (the-as int raw-id) 0)
        (set! (-> this switch-id) (the uint (the-as int raw-id)))
        (set! (-> this switch-id) 0))) ;; fallback if missing
  (format 0 "[INIT] Switch ID from lump: ~D~%" (-> this switch-id))
  (transform-post)
  (go idle)
  (none))



;;================== MASTER ==================;;

(deftype gravity-puzzle-master (process-drawable)
  ((switches-active uint)
   (required-mask  uint))
  (:states
   master-idle))

(defstate master-idle (gravity-puzzle-master)
  :event
    (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
      (case message
        (('notify)
         (let ((switch-bit (the int (-> block param 0)))
      (active?   (the int (-> block param 1))))
           (if (!= active? 0)
    (logior! (-> self switches-active) (ash 1 switch-bit))
    (logclear! (-> self switches-active) (ash 1 switch-bit)))
(format 0 "[PUZZLE MASTER] Switch ~D changed. Active mask: ~X~%"
        (the int (-> block param 0)) ;; ensure int for printing
        (-> self switches-active))
           (when (= (-> self switches-active) (-> self required-mask))
             (format 0 "[PUZZLE MASTER] All switches active! Triggering complete event~%")
             (ambient-hint-spawn "gravity-complete" (the-as vector #f) *entity-pool* 'stinger)
             (sound-play "arena-steps")
              ;; --- Send trigger to silostep ---
  (let ((count (entity-actor-count (-> self entity) 'alt-actor)))
    (dotimes (i count)
      (let ((linked (entity-actor-lookup (-> self entity) 'alt-actor i)))
        (when linked
          (let ((msg (new 'stack-no-clear 'event-message-block)))
            (set! (-> msg from) self)
            (set! (-> msg message) 'trigger-rise)
            (send-event-function (-> linked extra process) msg))))))))
         #t)
        ((#t) #f)))
  :code
    (behavior ()
      (loop (suspend)))
  :post #f)

(defmethod init-from-entity! ((this gravity-puzzle-master) (e entity-actor))
  (set! (-> this root) (new 'process 'trsqv))
  (process-drawable-from-entity! this e)
  (set! (-> this required-mask) #x1F)
  (set! (-> this switches-active) 0)
  (go master-idle)
  (none))


  ;; small swingpole ;;

(deftype small-swingpole (swingpole)
()
(:states
  small-swingpole-active
  small-swingpole-stance)
  )
  

(defstate small-swingpole-stance (small-swingpole)
  :code
    (behavior ()
      (loop
        (when (and *target*
                   (< (vector-vector-distance (-> self root trans) (-> *target* control unknown-vector90)) (-> self range))
                   (logtest? (-> *target* control root-prim prim-core action) (collide-action edgegrab-possible))
                   (< (-> *target* control unknown-vector90 y) (+ (-> self root trans y) (/ (-> self range) 2))))
          (if (send-event *target* 'pole-grab self) (go small-swingpole-active)))
        (suspend))))

(defstate small-swingpole-active (small-swingpole)
  :code
    (behavior ()
      (suspend)
      (while (and *target* (= (handle->process (-> *target* control unknown-handle10)) self))
        (suspend))
      (suspend-for (seconds 0.5))
      (go small-swingpole-stance)))


(defmethod init-from-entity! ((this small-swingpole) (arg0 entity-actor))
  "Copy defaults from the entity."
  (stack-size-set! (-> this main-thread) 128)
  (logior! (-> this mask) (process-mask actor-pause))
  (set! (-> this root) (new 'process 'trsq))
  (set! (-> this root trans quad) (-> arg0 extra trans quad))
  (quaternion-copy! (-> this root quat) (-> arg0 quat))
  (vector-identity! (-> this root scale))
  (vector-y-quaternion! (-> this dir) (-> this root quat))
  (set! (-> this dir y) 0.0)
  (vector-normalize! (-> this dir) 1.0)
  (set! (-> this range) 12288.0)
  (set! (-> this edge-length) 2192.0)
  (go small-swingpole-stance)
 
  (none))


;; long swingpole ;;

(deftype long-swingpole (swingpole)
()
(:states
  long-swingpole-active
  long-swingpole-stance)
  )
  

(defstate long-swingpole-stance (long-swingpole)
  :code
    (behavior ()
      (loop
        (when (and *target*
                   (< (vector-vector-distance (-> self root trans) (-> *target* control unknown-vector90)) (-> self range))
                   (logtest? (-> *target* control root-prim prim-core action) (collide-action edgegrab-possible))
                   (< (-> *target* control unknown-vector90 y) (+ (-> self root trans y) (/ (-> self range) 2))))
          (if (send-event *target* 'pole-grab self) (go long-swingpole-active)))
        (suspend))))

(defstate long-swingpole-active (long-swingpole)
  :code
    (behavior ()
      (suspend)
      (while (and *target* (= (handle->process (-> *target* control unknown-handle10)) self))
        (suspend))
      (suspend-for (seconds 0.5))
      (go long-swingpole-stance)))


(defmethod init-from-entity! ((this long-swingpole) (arg0 entity-actor))
  "Copy defaults from the entity."
   "Copy defaults from the entity."
  (stack-size-set! (-> this main-thread) 128)
  (logior! (-> this mask) (process-mask actor-pause))
  (set! (-> this root) (new 'process 'trsq))
  (set! (-> this root trans quad) (-> arg0 extra trans quad))
  (quaternion-copy! (-> this root quat) (-> arg0 quat))
  (vector-identity! (-> this root scale))
  (vector-y-quaternion! (-> this dir) (-> this root quat))
  (set! (-> this dir y) 0.0)
  (vector-normalize! (-> this dir) 1.0)
  (set! (-> this range) 16288.0)
  (set! (-> this edge-length) 12192.0)
  (go long-swingpole-stance)
 
  (none))




  ;; battle controller ;;
  (defskelgroup *preundgcam-sg*
  swampcam
  swampcam-lod0-jg
  swampcam-anim-ja
  ((swampcam-lod0-mg (meters 999999)))
  :bounds (static-spherem 0 0 0 15))

(deftype preundg-battlecontroller (battlecontroller) ())

(defstate battlecontroller-play-intro-camera (preundg-battlecontroller)
  :virtual #t
  :code
    (behavior ()
    (let ((gp-1 (ppointer->handle (process-spawn pov-camera (static-vectorm -1972.65 48.16 -41.40) *preundgcam-sg* "swamp-ambush" 0 #f '() :to self))))
        (while (handle->process (the-as handle gp-1))
          (suspend)))
      (go-virtual battlecontroller-active)))





;;custom ambush door;;

(def-actor ambushdoor :bounds (0 0 0 50))

(deftype ambushdoor (process-drawable)
  ((root collide-shape :override))
  (:methods
   (init-collision! (_type_) none))
  (:states
   open-door
   closed-door)) 


(defstate open-door (ambushdoor)
  :enter (behavior ()
           )
  :event
    (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
      (case message
        (('ambushdoor) (go closed-door))))
  :code
    (behavior ()
      (loop
        (suspend)))
  :post transform-post)


(defstate closed-door (ambushdoor)
  :enter (behavior ()
           ;; Move down 5 units
           (set! (-> (-> self root trans) y)
                 (- (-> (-> self root trans) y) (meters 15.0)))
           (transform-post)
           )
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
      (case message
        (('trigger) (format 0 "door should be open") (go open-door))))
  :code
    (behavior ()
      (loop
        (suspend)))
  :exit (behavior () (set! (-> (-> self root trans) y)
                 (+ (-> (-> self root trans) y) (meters 15.0)))
           (format 0 "Root trans after move: ~A" (-> self root trans))
           (transform-post)
           )
  :post transform-post)



(defmethod init-collision! ((this ambushdoor))
  (let ((cshape (new 'process 'collide-shape-moving this (collide-list-enum hit-by-player))))
    (set! (-> cshape dynam) (copy *standard-dynamics* 'process))
    (set! (-> cshape reaction) default-collision-reaction)
    (set! (-> cshape no-reaction)
          (the (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    (let ((cgroup (new 'process 'collide-shape-prim-group cshape (the uint 1) 0)))
      (set! (-> cgroup prim-core collide-as) (collide-kind ground-object))
      (set! (-> cgroup collide-with) (collide-kind target))
      (set! (-> cgroup prim-core action) (collide-action solid rider-plat-sticky))
      (set! (-> cgroup transform-index) 0)
      (set-vector! (-> cgroup local-sphere) 0.0 0.0 0.0 (meters 5))
      (set-root-prim! cshape cgroup)
      (let ((mesh (new 'process 'collide-shape-prim-mesh cshape (the uint 0) (the uint 0))))
        (set! (-> mesh prim-core collide-as) (collide-kind ground-object))
        (set! (-> mesh collide-with) (collide-kind target))
        (set! (-> mesh prim-core action) (collide-action solid rider-plat-sticky))
        (set! (-> mesh prim-core offense) (collide-offense indestructible))
        (set! (-> mesh transform-index) 0)
        (set-vector! (-> mesh local-sphere) 0.0 (meters 0) 0.0 (meters 5))
        (append-prim cgroup mesh)
        )
      )
    (set! (-> cshape nav-radius) (* 0.75 (-> cshape root-prim local-sphere w)))
    (backup-collide-with-as cshape)
    (set! (-> this root) cshape)
    )
  (none)
  )


  (defmethod init-from-entity! ((this ambushdoor) (e entity-actor))
  (init-collision! this) ;; allocate root and set up prim group
  (process-drawable-from-entity! this e) ;; copy position and rotation from entity
  (initialize-skeleton this *ambushdoor-sg* '()) ;; set up draw-control
  (update-transforms! (-> this root))
  (transform-post) ;; update our root transform
  (go open-door) ;; enter idle state
  (none)
  )

  