;;-*-Lisp-*-
(in-package goal)


(def-actor test-actor2 :bounds (0 0 0 50))

  (deftype test-actor2 (process-drawable)
  ((root       collide-shape-moving :override)
   (birth-time time-frame)
   (base       vector :inline)
   (old-base   vector :inline)
   (bob-offset int64)
   (bob-amount float))
  (:methods
   (init-collision! (_type_) none))
  (:state-methods
   idle))



(defmethod init-collision! ((this test-actor2))
  (let ((cshape (new 'process 'collide-shape-moving this (collide-list-enum hit-by-player))))
    (set! (-> cshape dynam) (copy *standard-dynamics* 'process))
    (set! (-> cshape reaction) default-collision-reaction)
    (set! (-> cshape no-reaction) (the (function collide-shape-moving collide-shape-intersect vector vector none) nothing))
    (let ((cgroup (new 'process 'collide-shape-prim-group cshape (the uint 1) 0)))
      (set! (-> cgroup prim-core collide-as) (collide-kind ground-object))
      (set! (-> cgroup collide-with) (collide-kind target))
      (set! (-> cgroup prim-core action) (collide-action solid rider-plat-sticky))
      (set! (-> cgroup transform-index) 0)
      (set-vector! (-> cgroup local-sphere) 0.0 0.0 0.0 (meters 5))
      (set-root-prim! cshape cgroup)
      (let ((mesh (new 'process 'collide-shape-prim-mesh cshape (the uint 0) (the uint 0))))
        (set! (-> mesh prim-core collide-as) (collide-kind ground-object))
        (set! (-> mesh collide-with) (collide-kind target))
        (set! (-> mesh prim-core action) (collide-action solid rider-plat-sticky))
        (set! (-> mesh prim-core offense) (collide-offense indestructible))
        (set! (-> mesh transform-index) 0)
        (set-vector! (-> mesh local-sphere) 0.0 (meters 0) 0.0 (meters 5))
        (append-prim cgroup mesh))
      ; (let ((sphere (new 'process 'collide-shape-prim-sphere cshape (the uint 0))))
      ;   (set! (-> sphere prim-core collide-as) (collide-kind enemy))
      ;   (set! (-> sphere collide-with) (collide-kind target))
      ;   (set! (-> sphere prim-core action) (collide-action solid))
      ;   (set! (-> sphere prim-core offense) (collide-offense normal-attack))
      ;   (set-vector! (-> sphere local-sphere) 0.0 0.0 0.0 (meters 2))
      ;   (set-root-prim! cshape sphere)
      ;   )
      )
    (set! (-> cshape nav-radius) (* 0.75 (-> cshape root-prim local-sphere w)))
    (backup-collide-with-as cshape)
    (set! (-> this root) cshape))
  (none))

(defmethod init-from-entity! ((this test-actor2) (e entity-actor))
  (logior! (-> this mask) (process-mask enemy))
  (init-collision! this)
  (process-drawable-from-entity! this e)
  (set! (-> this bob-amount) 1024.0)
  (set! (-> this bob-offset)
        (+ (the int (-> this root trans x)) (the int (-> this root trans y)) (the int (-> this root trans z))))
  (set-time! (-> this birth-time))
  (vector-copy! (-> this base) (-> this root trans))
  (vector-copy! (-> this old-base) (-> this root trans))
  (initialize-skeleton this *test-actor2-sg* '())
  (logclear! (-> this mask) (process-mask actor-pause))
  (transform-post)
  (go-virtual idle :proc this)
  (none))



(defstate idle (test-actor2)
  :virtual #t
  :event
    (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
      (case message
        (('attack 'touch)
         ; (if (= (-> proc type) target)
         ;   (send-event proc 'attack #f (static-attack-info ((shove-up (meters 2.5)) (shove-back (meters 7.5)))))
         ;   )
         #t)))
  :code
    (behavior ()
      (loop
        (when (task-complete? *game-info* (game-task brume-restore-power)) ;; added temp game-task to be completed by yellow eggtop. spinners "power on" when completed
  (quaternion-rotate-y! (-> self root quat) (-> self root quat) (* (degrees 20) (seconds-per-frame))))

        ; (debug-draw-tris (-> (res-lump-struct (-> self draw art-group data 0 extra) 'collide-mesh-group (array collide-mesh)) 0) self 2)
        ; (dotimes (i (-> self node-list length))
        ;   (let* ((joint (-> self node-list data i)) (jpos (vector<-cspace! (new-stack-vector0) joint)))
        ;     (add-debug-sphere #t (bucket-id debug) jpos (meters 0.1) (static-rgba 0 #xff 0 #x40))
        ;     (add-debug-text-sphere (!= (-> joint joint) #f) (bucket-id debug) jpos (meters 0.1) (-> joint joint name) (static-rgba 0 #xff 0 #x40))
        ;     )
        ;   )
        (suspend)))
  :post transform-post)

(deftype v4-part (part-spawner) ())


(defpartgroup group-v4-waterfall-1
  :id 153
  :flags (always-draw)
  :bounds (static-bspherem 0 16 0 32)
  :parts
  ((sp-item 782 :fade-after (meters 160) :falloff-to (meters 160))
   ))

(defpart 782
  :init-specs
  ((:texture (new 'static 'texture-id :index #x18 :page #x2))
   (:num 20.9)
   (:x (meters -19) (meters 10))
   (:y (meters 47))
   (:z (meters -10) (meters 20))
   (:scale-x (meters 2.4) (meters 1.6))
   (:scale-y (meters 1.2) (meters 0.8))
   (:r 192.0)
   (:g 192.0)
   (:b 192.0)
   (:a 32.0 16.0)
   (:vel-x (meters 0.05))
   (:vel-y (meters 0.013333334) (meters 0.013333334))
   (:vel-z (meters -0.0016666667) (meters 0.0033333334))
   (:scalevel-x (meters 0.0073242188))
   (:scalevel-y (meters 0.029296875))
   (:accel-x (meters -0.00091074686))
   (:accel-y (meters -0.0036666668) (meters -0.00066666666))
   (:timer (seconds 1.28))
   (:flags (bit2))
   (:next-time (seconds 1.23))
   (:launchrot-x (degrees -15) (degrees 30))
   (:rotate-y (degrees -80))))

(defpartgroup group-v4-waterfall-1-small
  :id 154
  :flags (always-draw)
  :bounds (static-bspherem 0 16 0 32)
  :parts
  ((sp-item 783 :fade-after (meters 160) :falloff-to (meters 160))
   ))

(defpart 783
  :init-specs
  ((:texture (new 'static 'texture-id :index #x18 :page #x2))
   (:num 10.9)
   (:x (meters -10) (meters 10))
   (:y (meters 47))
   (:z (meters 5) (meters 15))
   (:scale-x (meters 2.4) (meters 1.6))
   (:scale-y (meters 1.2) (meters 0.8))
   (:r 192.0)
   (:g 192.0)
   (:b 192.0)
   (:a 32.0 16.0)
   (:vel-x (meters 0.05))
   (:vel-y (meters 0.013333334) (meters 0.013333334))
   (:vel-z (meters -0.0016666667) (meters 0.0033333334))
   (:scalevel-x (meters 0.0073242188))
   (:scalevel-y (meters 0.029296875))
   (:accel-x (meters -0.00091074686))
   (:accel-y (meters -0.0036666668) (meters -0.00066666666))
   (:timer (seconds 1.28))
   (:flags (bit2))
   (:next-time (seconds 1.23))
   (:launchrot-x (degrees -15) (degrees 30))
   (:rotate-y (degrees -120))))

(defpartgroup group-v4-waterfall-1-smallest
  :id 155
  :flags (always-draw)
  :bounds (static-bspherem 0 16 0 32)
  :parts
  ((sp-item 784 :fade-after (meters 160) :falloff-to (meters 160))
   ))

(defpart 784
  :init-specs
  ((:texture (new 'static 'texture-id :index #x18 :page #x2))
   (:num 10.9)
   (:x (meters -9) (meters 5))
   (:y (meters 47))
   (:z (meters -1) (meters 4))
   (:scale-x (meters 2.4) (meters 1.6))
   (:scale-y (meters 1.2) (meters 0.8))
   (:r 192.0)
   (:g 192.0)
   (:b 192.0)
   (:a 32.0 16.0)
   (:vel-x (meters 0.05))
   (:vel-y (meters 0.013333334) (meters 0.013333334))
   (:vel-z (meters -0.0016666667) (meters 0.0033333334))
   (:scalevel-x (meters 0.0073242188))
   (:scalevel-y (meters 0.029296875))
   (:accel-x (meters -0.00091074686))
   (:accel-y (meters -0.0036666668) (meters -0.00066666666))
   (:timer (seconds 1.28))
   (:flags (bit2))
   (:next-time (seconds 1.23))
   (:launchrot-x (degrees -15) (degrees 30))
   (:rotate-y (degrees 120))))

(defpartgroup group-v4-fog
  :id 207
  :bounds (static-bspherem 64 7 0 96)
  :parts ((sp-item 982 :flags (is-3d))))

(defpart 982
  :init-specs
  ((:texture (middot effects))
   (:num 0.06125)
   (:x (meters 0) (meters 128))
   (:y (meters 5.5) (meters 1.5))
   (:z (meters -20) (meters 80))
   (:scale-x (meters 36))
   (:rot-y (degrees 0) (degrees 360))
   (:scale-y :copy scale-x)
   (:r 127.0)
   (:g 127.0)
   (:b 95.0 32.0)
   (:a 0.0)
   (:scalevel-x (meters 0.013333334) (meters 0.006666667))
   (:rotvel-y (degrees -0.033333335) (degrees 0.06666667))
   (:scalevel-y :copy scalevel-x)
   (:fade-a 0.21333334)
   (:timer (seconds 10))
   (:flags (bit2 bit14 left-multiply-quat))
   (:next-time (seconds 1) (seconds 0.997))
   (:next-launcher 983)
   (:conerot-x (degrees 90))
   (:conerot-y (degrees 0) (degrees 360))
   (:conerot-radius (meters 16) (meters 32))
   (:rotate-y (degrees 25.000002))))

(defpart 983
  :init-specs ((:fade-a 0.0) (:next-time (seconds 4) (seconds 0.997)) (:next-launcher 984)))

(defpart 984
  :init-specs ((:fade-a -0.21333334)))


(defpartgroup group-v4-fog-cloud
  :id 205
  :bounds (static-bspherem 0 300.5 0 300.5)
  :parts
  ((sp-item 972 :fade-after (meters 175) :falloff-to (meters 175) :period (seconds 5) :length (seconds 10))
   (sp-item 972 :fade-after (meters 175) :falloff-to (meters 175) :period (seconds 9.76) :length (seconds 10.2))
   (sp-item 972 :fade-after (meters 175) :falloff-to (meters 175) :period (seconds 15.34) :length (seconds 10.6))
   (sp-item 973 :fade-after (meters 125) :falloff-to (meters 125) :period (seconds 10.6) :length (seconds 10.15))))

(defpart 972
  :init-specs
  ((:texture (middot effects))
   (:num 1.0 1.0)
   (:y (meters 0.5) (meters 2))
   (:scale-x (meters 32))
   (:rot-z (degrees 0) (degrees 360))
   (:scale-y :copy scale-x)
   (:r 192.0)
   (:g 192.0)
   (:b 192.0 32.0)
   (:a 150.0)
   (:vel-y (meters 0.0) (meters 0.00))
   (:scalevel-x (meters 0.0048828125))
   (:rotvel-z (degrees -0.1) (degrees 0.2))
   (:scalevel-y :copy scalevel-x)
   (:fade-a -0.21333334)
   (:accel-y (meters 0.000))
   (:friction 0.996)
   (:timer (seconds 4) (seconds 3.5))
   (:flags (bit2 bit12 bit14))
   (:conerot-x (degrees 90))
   (:conerot-y (degrees 0) (degrees 360))
   (:conerot-radius (meters 0) (meters 200))))

(defpart 973
  :init-specs
  ((:texture (middot effects))
   (:num 2.0 4.0)
   (:y (meters 0.5) (meters 2))
   (:scale-x (meters 16))
   (:rot-z (degrees 0) (degrees 360))
   (:scale-y :copy scale-x)
   (:r 192.0)
   (:g 192.0)
   (:b 192.0 32.0)
   (:a 150.0)
   (:vel-y (meters 0.0) (meters 0.00))
   (:scalevel-x (meters 0.0048828125))
   (:rotvel-z (degrees -0.1) (degrees 0.2))
   (:scalevel-y :copy scalevel-x)
   (:fade-a -0.10666667)
   (:accel-y (meters 0.000))
   (:friction 0.993)
   (:timer (seconds 4) (seconds 3.5))
   (:flags (bit2 bit12 bit14))
   (:conerot-x (degrees 90))
   (:conerot-y (degrees 0) (degrees 360))
   (:conerot-radius (meters 0) (meters 200))))





;;/////////////////NPC-MUSE///////////////////////;;

(deftype muse-v4-catchable (nav-enemy)
  ((root               collide-shape-moving :override)
   (current-path-index float)
   (prev-path-index    float)
   (dest-path-index    float)
   (player-path-index  float)
   (max-path-index     float)
   (sprint-distance    float)
   (dest-point         vector :inline)
   (anim               spool-anim)
   (victory-anim       spool-anim)
   (old-target-pos     transformq :inline)
   )
  (:states
   muse-v4-catchable-caught
   muse-v4-catchable-idle
   hide-n-seek-catchable))
(deftype muse-v4 (nav-enemy)
  ((root               collide-shape-moving :override)
   (current-path-index float)
   (prev-path-index    float)
   (dest-path-index    float)
   (player-path-index  float)
   (max-path-index     float)
   (sprint-distance    float)
   (interacted?        symbol)
   (dest-point         vector :inline)
   (anim               spool-anim)
   (victory-anim       spool-anim)
   (old-target-pos     transformq :inline)
   (child-process         (pointer muse-v4-catchable) :overlay-at child)
   (minigame-timer ticky :inline))
  (:states
   muse-v4-idle
   hide-n-seek))

(defskelgroup *muse-sg*
  muse
  muse-lod0-jg
  muse-idle-ja
  ((muse-lod0-mg (meters 999999)))
  :bounds (static-spherem 0 2 0 3))

(defstate muse-v4-idle (muse-v4)
  :enter
  (behavior ()
    (logclear! (-> self draw status) (draw-status hidden))
    (restore-collide-with-as (-> self root)))
  :trans
  (behavior ()
    (when (and *target*
               ;; Only show prompt if all 3 aren't done yet
               (not (and
                         (task-complete? *game-info* (game-task brume-muse-hide-3))))
               (>= 51920.0 (vector-vector-distance (-> self root trans) (-> *target* control trans))))
      ;; Show "Press O to hide and seek!" only if close enough and game not fully done
      (when (hud-hidden?)
        (let ((gp-0 (new 'stack 'font-context *font-default-matrix* 32 160 0.0
                         (font-color default)
                         (font-flags shadow kerning))))
          (set! (-> gp-0 flags) (font-flags shadow kerning large))
          (print-game-text (lookup-text! *common-text* (text-id press-hide-seek) #f)
                           gp-0 #f 128 22)))
      (when (cpad-pressed? 0 circle)
        (go hide-n-seek))))
  :code
  (behavior ()
    ;; Idle animation loop
    (loop
      (ja-no-eval :group! muse-idle-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (spool-push *art-control* (-> self anim name) 0 self -99.0)
        (nav-enemy-method-51 self)
        (suspend)
        (ja :num! (seek!)))))
  :post ja-post)
(defmethod nav-enemy-method-51 ((this muse-v4))
  (dotimes (s5-0 2)
    (let ((v1-2 (rand-vu-int-range 3 (+ (-> this node-list length) -1))))
      (launch-particles (-> *part-id-table* 271) (vector<-cspace! (new 'stack-no-clear 'vector) (-> this node-list data v1-2)))))
  0
  (none))

;;(defstate after-query (muse-v4)
;;  :enter
;;  (behavior ()
;;    (format 0 "Player accepted the hide and seek offer!")
;;   (set-blackout-frames 1000)
;;    (go fade-out-hide)))

(defstate hide-n-seek (muse-v4)
  :event
    (behavior ((proc process) (argc int) (msg symbol) (block event-message-block))
    (case msg
      (('caught-hide-n-seek)
       (format 0 "[NPC MUSE] Received caught-hide-n-seek from ~A~%" proc)

       (go muse-v4-idle))))
  :enter
(behavior ()
  (set-blackout-frames (seconds 1.2))
  (sound-play "muse-taunt-1")
  (sound-play "muse-taunt-2")
  (play-sound-file "sound_replacements/musesteps.mp3" 100)
  (set-time! (-> self state-time))
  (sleep (-> self minigame-timer) (seconds 60))
  (format 0 "[NPC MUSE] Entered hide-n-seek state")
  (let ((count (entity-actor-count (-> self entity) 'alt-actor))
        (target-actor (the-as entity-actor #f)))
    (dotimes (i count)
      (let ((linked (entity-actor-lookup (-> self entity) 'alt-actor i)))
        (when linked
          (let ((task-symbol (-> linked extra perm task)))
            (when (and (not (task-complete? *game-info* task-symbol))
                       (not target-actor))
              (format 0 "[NPC MUSE] Selected alt-actor ~A with task ~A~%" i task-symbol)
              (set! target-actor linked))))))

    (if target-actor
      (let ((msg (new 'stack-no-clear 'event-message-block)))
        (set! (-> msg from) self)
        (set! (-> msg num-params) 0)
        (set! (-> msg message) 'start-hide-n-seek)
        (send-event-function (-> target-actor extra process) msg))
      (format 0 "[NPC MUSE] No available muse left to start~%")))

  ;; Hide NPC muse
  (logior! (-> self draw status) (draw-status hidden))
  (clear-collide-with-as (-> self root)))
  :trans
  (behavior ()
  (when (completed? (-> self minigame-timer))
    ;; Timer expired, send fail to catchable muse
    (let ((count (entity-actor-count (-> self entity) 'alt-actor)))
      (dotimes (i count)
        (let ((linked (entity-actor-lookup (-> self entity) 'alt-actor i)))
          (when linked
            (let ((msg (new 'stack-no-clear 'event-message-block)))
              (set! (-> msg from) self)
              (set! (-> msg message) 'fail-hide-n-seek)
              (ambient-hint-spawn "st-lose" (the-as vector #f) *entity-pool* 'stinger)
              (send-event-function (-> linked extra process) msg))))))
    (go muse-v4-idle))
  (suspend))
  :code
  (behavior ()
    ;; Keeps it in this state, doing nothing (invisible & idle)
    (loop
      (suspend)))
   ; yields each frame to prevent freeze
  :post ja-post)

;;(defstate hide-n-seek-go! (muse-v4)
;;  :code
;;  (behavior ()
;;    (format 0 "THIS HAS REACHED THE FADEOUTHIDESTATE")
;;    (logior! (-> self draw status) (draw-status hidden))
;;    (clear-collide-with-as (-> self root))
;;    (set-blackout-frames 1000)
;;    (suspend)))

(defmethod init-from-entity! ((this muse-v4) (arg0 entity-actor))
  (stack-size-set! (-> this main-thread) 512)
  (logior! (-> this mask) (process-mask enemy))
  (let ((s4-0 (new 'process 'collide-shape-moving this (collide-list-enum hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) default-collision-reaction)
    (set! (-> s4-0 no-reaction) (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing))
    (let ((s3-0 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
      (set! (-> s3-0 prim-core collide-as) (collide-kind enemy))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set! (-> s3-0 prim-core offense) (collide-offense indestructible))
      (set-vector! (-> s3-0 local-sphere) 0.0 2457.6 0.0 2457.6)
      (set-root-prim! s4-0 s3-0))
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> this collide-info) s4-0))
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton this *muse-sg* '())
  (logclear! (-> this mask) (process-mask actor-pause))
  (init-defaults! this *muse-nav-enemy-info*)
  (set! (-> this max-path-index) (the float (+ (-> this path curve num-cverts) -1)))
  (set! (-> this current-path-index) 0.0)
  (set! (-> this prev-path-index) 0.0)
  (set! (-> this dest-path-index) 0.0)
  (set! (-> this player-path-index) 0.0)
  (eval-path-curve-div! (-> this path) (-> this dest-point) (-> this current-path-index) 'interp)
  (set! (-> this collide-info trans quad) (-> this dest-point quad))
  (set! (-> this nav nearest-y-threshold) 20480.0)
  (set-vector! (-> this neck twist-max) 8192.0 8192.0 0.0 1.0)
  (set! (-> this neck up) (the-as uint 0))
  (set! (-> this neck nose) (the-as uint 1))
  (set! (-> this neck ear) (the-as uint 2))
  (set! (-> this neck max-dist) 102400.0)
  (set! (-> this neck ignore-angle) 16384.0)
  (set! (-> this anim)
        (new 'static 'spool-anim :name "muse-victory" :index 9 :parts 2 :command-list '((1 blackout 0) (219 blackout 60))))
  (set! (-> this victory-anim) (fuel-cell-pick-anim this))
  (go muse-v4-idle)
  (none))

;;/////////////////CATCHABLE-MUSE///////////////////////;;

(deftype point-on-path-segment-info (structure)
  ((point               vector :inline)
   (segment             vector 2 :inline)
   (dir                 vector :inline)
   (nearest-point       vector :inline)
   (segment-length      float)
   (distance-to-segment float)
   (parametric-index    float)))

(defun analyze-point-on-path-segment ((arg0 point-on-path-segment-info))
  (vector-! (-> arg0 dir) (-> arg0 segment 1) (the-as vector (-> arg0 segment)))
  (vector-normalize! (-> arg0 dir) 1.0)
  (set! (-> arg0 segment-length) (vector-vector-distance (the-as vector (-> arg0 segment)) (-> arg0 segment 1)))
  (let ((s5-0 (new 'stack-no-clear 'vector)))
    (vector-! s5-0 (the-as vector (-> arg0 segment)) (-> arg0 point))
    (vector+*! s5-0 s5-0 (-> arg0 dir) (- (vector-dot s5-0 (-> arg0 dir))))
    (vector+! (-> arg0 nearest-point) (-> arg0 point) s5-0)
    (set! (-> arg0 distance-to-segment) (vector-length s5-0))
    (vector-! s5-0 (-> arg0 point) (the-as vector (-> arg0 segment)))
    (set! (-> arg0 parametric-index) (/ (vector-dot (-> arg0 dir) s5-0) (-> arg0 segment-length))))
  (cond
    ((< (-> arg0 parametric-index) 0.0)
     (set! (-> arg0 parametric-index) 0.0)
     (set! (-> arg0 nearest-point quad) (-> arg0 segment 0 quad))
     (set! (-> arg0 distance-to-segment) (vector-vector-distance (-> arg0 nearest-point) (-> arg0 point))))
    ((< 1.0 (-> arg0 parametric-index))
     (set! (-> arg0 parametric-index) 1.0)
     (set! (-> arg0 nearest-point quad) (-> arg0 segment 1 quad))
     (set! (-> arg0 distance-to-segment) (vector-vector-distance (-> arg0 nearest-point) (-> arg0 point))))))

(defbehavior muse-get-path-point muse ((arg0 vector) (arg1 int))
  (eval-path-curve-div! (-> self path) arg0 (the float arg1) 'interp)
  0
  (none))

(defbehavior muse-check-dest-point muse ()
  (let ((gp-0 (new 'stack-no-clear 'point-on-path-segment-info))
        (f26-0 4096000.0)
        (f30-0 0.0)
        (f24-0 4096000.0)
        (f28-0 0.0))
    (let ((s5-0 (+ (-> self path curve num-cverts) -1))
          (s4-0 (target-pos 0)))
      (dotimes (s3-0 s5-0)
        (let ((f22-0 (the float s3-0)))
          (let ((f20-0 (the float (+ s3-0 1))))
            (eval-path-curve-div! (-> self path) (the-as vector (-> gp-0 segment)) f22-0 'interp)
            (eval-path-curve-div! (-> self path) (-> gp-0 segment 1) f20-0 'interp))
          (set! (-> gp-0 point quad) (-> s4-0 quad))
          (analyze-point-on-path-segment gp-0)
          (when (< (-> gp-0 distance-to-segment) f24-0)
            (set! f24-0 (-> gp-0 distance-to-segment))
            (set! f28-0 (+ f22-0 (-> gp-0 parametric-index))))
          (set! (-> gp-0 point quad) (-> self collide-info trans quad))
          (analyze-point-on-path-segment gp-0)
          (when (< (-> gp-0 distance-to-segment) f26-0)
            (set! f26-0 (-> gp-0 distance-to-segment))
            (set! f30-0 (+ f22-0 (-> gp-0 parametric-index)))))
        0))
    (let ((f0-6 (- f30-0 f28-0)))
      (if (< f0-6 (* -0.5 (-> self max-path-index))) (+! f0-6 (-> self max-path-index)))
      (if (< (* 0.5 (-> self max-path-index)) f0-6) (set! f0-6 (- f0-6 (-> self max-path-index))))
      (cond
        ((>= f0-6 0.0)
         (set! (-> self dest-path-index) (the float (the int (+ 2.5 f30-0))))
         (if (>= (-> self dest-path-index) (-> self max-path-index))
           (set! (-> self dest-path-index) (- (-> self dest-path-index) (-> self max-path-index)))))
        (else
         (set! (-> self dest-path-index) (+ -1.5 f30-0))
         (if (< (-> self dest-path-index) 0.0) (+! (-> self dest-path-index) (-> self max-path-index)))
         (set! (-> self dest-path-index) (the float (the int (-> self dest-path-index))))))))
  (eval-path-curve-div! (-> self path) (-> self dest-point) (-> self dest-path-index) 'interp)
  0
  (none))

(defmethod nav-enemy-method-51 ((this muse-v4-catchable))
  (dotimes (s5-0 5) ;; iterates how many times this is run. increased from 2 to 5 for more particles launched.
    (let ((v1-2 (rand-vu-int-range 3 (+ (-> this node-list length) -1))))
      (launch-particles (-> *part-id-table* 279) (vector<-cspace! (new 'stack-no-clear 'vector) (-> this node-list data v1-2))))) ;;271 is default. 260 is pretty blue. 277 is green eco effect. 279 is sparkly green.
  0
  (none))

(defmethod common-post ((this muse-v4-catchable))
  (spool-push *art-control* (-> this anim name) 0 this -99.0)
  (nav-enemy-method-51 this)
  ((method-of-type nav-enemy common-post) this)
  (none))

(defmethod touch-handler ((this muse-v4-catchable) (arg0 process) (arg1 event-message-block))
  (go muse-v4-catchable-caught))

(defmethod attack-handler ((this muse-v4-catchable) (arg0 process) (arg1 event-message-block))
  (go muse-v4-catchable-caught))

nav-enemy-default-event-handler

(defbehavior muse-v4-catchable-events muse-v4-catchable ((proc process) (argc int) (msg symbol) (block event-message-block))
  (case msg
    (('start-hide-n-seek)
     (format 0 "[CATCHABLE MUSE] Received start-hide-n-seek~%")
     (go hide-n-seek-catchable))

    (('fail-hide-n-seek)
     (format 0 "[CATCHABLE MUSE] Minigame failed. Resetting to idle~%")
     (go muse-v4-catchable-idle))

    (('caught-hide-n-seek)
     (format 0 "[CATCHABLE MUSE] Minigame already caught, maybe cleanup?~%")
     ;; optional logic if you want something to happen on win
     )
     (else
     (nav-enemy-default-event-handler proc argc msg block))))



(defstate muse-v4-catchable-idle (muse-v4-catchable)
  :event muse-v4-catchable-events
  :enter
  (behavior ()
  (logior! (-> self draw status) (draw-status hidden))
  (clear-collide-with-as (-> self root))
  )
  :trans
    (behavior ())
    ;;  (seek! (-> self sprint-distance) 161440.0 (* 8192.0 (seconds-per-frame))) ;; value is how long the muse can sprint for
     ;; (if (and *target* (>= 102400.0 (vector-vector-distance (-> self collide-info trans) (-> *target* control trans))))
     ;;   (level-hint-spawn (text-id zero) (the-as string #f) (-> self entity) *entity-pool* (game-task none)))
     ;; (if (and *target* (>= 81920.0 (vector-vector-distance (-> self collide-info trans) (-> *target* control trans))))
     ;;   (go-virtual nav-enemy-chase)))
  :code
    (behavior ()
      (when (ja-group? muse-run-ja)
        (ja-channel-push! 1 (seconds 0.1))
        (ja-no-eval :num! (loop!))
        (ja-no-eval :group! muse-run-to-idle-ja :num! (seek!) :frame-num 0.0)
        (until (ja-done? 0)
          (ja-blend-eval)
          (suspend)
          (ja :num! (seek!))))
      (loop
        (ja-no-eval :group! muse-idle-ja :num! (seek!) :frame-num 0.0)
        (until (ja-done? 0)
          (spool-push *art-control* (-> self anim name) 0 self -99.0)
          ;;(nav-enemy-method-51 self)
          (suspend)
          (ja :num! (seek!)))))
  :post ja-post)

(defstate hide-n-seek-catchable (muse-v4-catchable)
 :event muse-v4-catchable-events
  :enter
  (behavior ()
    (logclear! (-> self draw status) (draw-status hidden))
    (restore-collide-with-as (-> self root))
    (format 0 "[CATCHABLE MUSE] Entered hide-n-seek-catchable~%"))
  :code
  (behavior ()
    (loop
      ;; Idle wagging animation
      (ja-no-eval :group! muse-idle-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        ;; Sparkly particles along the path
        (dotimes (i 20 (-> self path curve num-cverts))
          (let ((v (new 'stack-no-clear 'vector)))
            (eval-path-curve-div! (-> self path) v (the float i) 'interp)
            (launch-particles (-> *part-id-table* 271) v)))
        ;; Push anim, run wagging sparkle logic
        (spool-push *art-control* (-> self anim name) 0 self -99.0)
        (nav-enemy-method-51 self)
        (suspend)
        (ja :num! (seek!)))))
  :post ja-post)


(defstate nav-enemy-chase (muse-v4-catchable)
  :virtual #t
  :event nav-enemy-default-event-handler
  :enter
    (behavior ()
      (set-time! (-> self state-time)))
  :trans
    (behavior ()
      (cond
        ((or (not *target*) (< 202400.0 (vector-vector-distance (-> self collide-info trans) (-> *target* control trans)))) ;; distance in which the muse can be from you.
         (set! (-> self target-speed) 0.0)
         (if (= (-> self momentum-speed) 0.0) (go muse-v4-catchable-idle)))
        ((or (not *target*)
             (< (-> self sprint-distance) (vector-vector-distance (-> self collide-info trans) (-> *target* control trans))))
         (set! (-> self target-speed) 40960.0))
        (else (set! (-> self target-speed) 61440.0))) ;; sprint speed of muse
      (seek! (-> self sprint-distance) 0.0 (* 4096.0 (seconds-per-frame)))
      (muse-check-dest-point))
  :code
    (behavior ()
      (cond
        ((ja-group? muse-idle-ja)
         (ja-channel-push! 1 (seconds 0.1))
         (ja-no-eval :num! (loop!))
         (ja-no-eval :group! muse-idle-to-run-ja :num! (seek!) :frame-num 0.0)
         (until (ja-done? 0)
           (ja-blend-eval)
           (suspend)
           (ja :num! (seek!))))
        (else (ja-channel-push! 1 (seconds 0.1))))
      (ja :group! muse-run-ja :num! min)
      (loop
        (suspend)
        (ja :num! (loop! (* 0.000016276043 (-> self momentum-speed))))))
  :post
    (behavior ()
      (set! (-> self nav destination-pos quad) (-> self dest-point quad))
      (nav-control-method-19 (-> self nav)
                             (-> self nav target-pos)
                             (-> self collide-info)
                             (-> self nav destination-pos)
                             546133.3)
      (if (logtest? (nav-control-flags navcf21) (-> self nav flags)) (logclear! (-> self nav flags) (nav-control-flags navcf10)))
      (nav-enemy-travel-post)))

(defstate nav-enemy-jump (muse-v4-catchable)
  :virtual #t
  :event nav-enemy-default-event-handler
  :enter
    (behavior ()
      ((-> (method-of-type nav-enemy nav-enemy-jump) enter))
      (logclear! (-> self nav-enemy-flags) (nav-enemy-flags standing-jump)))
  :code
    (-> (method-of-type nav-enemy nav-enemy-jump)
        code))

(defstate nav-enemy-jump-land (muse-v4-catchable)
  :virtual #t
  :event nav-enemy-default-event-handler
  :code
    (behavior ()
      (ja-no-eval :num! (seek!))
      (ja-channel-push! 1 (seconds 0.075))
      (ja-no-eval :group! muse-run-ja :num! (seek! max 0.8) :frame-num (ja-aframe 6.0 0))
      (until (ja-done? 0)
        (ja-blend-eval)
        (suspend)
        (ja :num! (seek! max 0.8)))
      (go-virtual nav-enemy-chase)))

(defstate muse-v4-catchable-caught (muse-v4-catchable)
  :event #f
  :enter
   (behavior  ()
   (let ((msg (new 'stack-no-clear 'event-message-block)))
  (set! (-> msg from) self)
  (set! (-> msg num-params) 0)
  (set! (-> msg message) 'caught-hide-n-seek)
  ;; Send back to NPC muse (e.g. parent, or use alt-actor 0 if that’s how they’re linked)
  (send-event-function (-> (entity-actor-lookup (-> self entity) 'alt-actor 0) extra process) msg))
)
  :trans
    (behavior ()
      (spool-push *art-control* (-> self anim name) 0 self -1.0))
  :code
    (behavior ()
      (sound-play "money-pickup")
      ;;(close-specific-task! (game-task overgrown-muse) (task-status need-reminder))
      (process-entity-status! self (entity-perm-status dead) #t)
      (when (not (= (-> self entity extra perm task) (game-task brume-muse-hide-3)))
  (close-specific-task! (-> self entity extra perm task) (task-status need-resolution))
  (set! (-> self entity extra perm task) (game-task complete)))
      (suspend)
      (when (send-event *target* 'clone-anim self)
        (set-blackout-frames (seconds 10))
        (let ((gp-1 (res-lump-struct (-> self entity) 'movie-pos vector)))
          (cond
            (gp-1 (move-to-point! (-> self collide-info) gp-1) (set-yaw-angle-clear-roll-pitch! (-> self collide-info) (-> gp-1 w)))
            (else
             (move-to-point! (-> self collide-info) (-> *target* control trans))
             (quaternion-copy! (-> self collide-info quat) (-> *target* control quat))
             (move-to-ground (-> self collide-info) 40960.0 40960.0 #f (collide-kind background)))))
        (send-event *target* 'trans 'save (-> self old-target-pos))
        (send-event (ppointer->process (-> *target* sidekick)) 'matrix 'play-anim)
        (send-event *target* 'blend-shape #t)
        (if (= *kernel-boot-message* 'play)
        (format 0 "Inside non-play mode branch one~%")
          (set! (-> self trans-hook)
                (lambda :behavior muse ()
                  (spool-push *art-control* (-> self victory-anim name) 0 self -1.0)
                  (none))))
        (add-setting! 'music-volume 'rel (-> *setting-control* current music-volume-movie) 0)
        (add-setting! 'sfx-volume 'rel (-> *setting-control* current sfx-volume-movie) 0)
        (add-setting! 'ambient-volume 'rel (-> *setting-control* current ambient-volume-movie) 0)
        (logclear! (-> self mask) (process-mask enemy))
        (process-spawn othercam self 3 #f #t :to self)
        (auto-save-command 'auto-save 0 0 *default-pool*)
        (ja-play-spooled-anim (-> self anim)
                              (the-as art-joint-anim muse-idle-ja)
                              (the-as art-joint-anim muse-idle-ja)
                              (the-as (function process-drawable symbol) false-func))
        (remove-setting! 'music-volume)
        (remove-setting! 'sfx-volume)
        (remove-setting! 'ambient-volume)
        (send-event *target* 'blend-shape #f)
        (cond
          ((= *kernel-boot-message* 'play)
          (format 0 "Inside nonplay mode branch 2.~%")
           (set-blackout-frames 0)
           (ja-channel-set! 0)
           (ja-post)
           (clear-collide-with-as (-> self collide-info))
           ;;(send-event *target* 'trans 'reset)
           (send-event *target* 'trans 'restore (-> self old-target-pos))
  (format 0 "Did task-complete? detect it? ~A~%" (task-complete? *game-info* (game-task brume-muse-hide-1)))
  (when (= (-> self entity extra perm task) (game-task brume-muse-hide-3))
  (let ((gp-4 (ppointer->handle (birth-pickup-at-point (target-pos 0)
                                                       (pickup-type fuel-cell)
                                                       (the float (-> self entity extra perm task))
                                                       #f
                                                       self
                                                       (the-as fact-info #f)))))
    (send-event (handle->process (the-as handle gp-4)) 'pickup)
    (while (handle->process (the-as handle gp-4))
      (send-event *target* 'trans 'restore (-> self old-target-pos))
      (send-event *camera* 'teleport (-> self old-target-pos))
      (send-event *camera* 'no-intro)
      (send-event *camera* 'clear-entity)
      (send-event *camera* 'force-blend 0)
      (send-event *camera* 'change-state cam-fixed 0)
      (send-event *camera* 'change-state cam-string 0)
      (suspend)))
      ))

          (else
            (format 0 "Inside play mode branch.~%")
           (send-event *target* 'trans 'restore (-> self old-target-pos))
           (set-blackout-frames 0)
           (set-blackout-frames (seconds 0.1))))))
  :post
    (behavior ()
      (nav-enemy-method-51 self)
      (level-hint-surpress!)
      (kill-current-level-hint '() '() 'exit)
      (ja-post)))

(define *muse-nav-enemy-info*
  (new 'static
       'nav-enemy-info
       :idle-anim 3
       :walk-anim 4
       :turn-anim -1
       :notice-anim 3
       :run-anim 4
       :jump-anim 7
       :jump-land-anim 8
       :victory-anim 3
       :taunt-anim 3
       :die-anim 3
       :neck-joint 6
       :player-look-at-joint 5
       :run-travel-speed (meters 10)
       :run-rotate-speed (degrees 999.99994)
       :run-acceleration (meters 5)
       :run-turn-time (seconds 0.15)
       :walk-travel-speed (meters 10)
       :walk-rotate-speed (degrees 999.99994)
       :walk-acceleration (meters 1)
       :walk-turn-time (seconds 0.15)
       :attack-shove-back (meters 3)
       :attack-shove-up (meters 2)
       :shadow-size (meters 2)
       :notice-nav-radius (meters 1)
       :nav-nearest-y-threshold (meters 10)
       :notice-distance (meters 30)
       :stop-chase-distance (meters 40)
       :frustration-distance (meters 8)
       :frustration-time (seconds 4)
       :die-anim-hold-frame 10000000000.0
       :jump-anim-start-frame 6.5
       :jump-land-anim-end-frame 10000000000.0
       :jump-height-min (meters 1)
       :jump-height-factor 0.5
       :jump-start-anim-speed 1.0
       :shadow-max-y (meters 1)
       :shadow-min-y (meters -1)
       :shadow-locus-dist (meters 150)
       :use-align #f
       :draw-shadow #t
       :move-to-ground #t
       :hover-if-no-ground #f
       :use-momentum #f
       :use-flee #f
       :use-proximity-notice #f
       :use-jump-blocked #f
       :use-jump-patrol #f
       :gnd-collide-with (collide-kind background)
       :debug-draw-neck #f
       :debug-draw-jump #f))

(defmethod init-from-entity! ((this muse-v4-catchable) (arg0 entity-actor))
  (stack-size-set! (-> this main-thread) 512)
  (logior! (-> this mask) (process-mask enemy))
  (let ((s4-0 (new 'process 'collide-shape-moving this (collide-list-enum hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) default-collision-reaction)
    (set! (-> s4-0 no-reaction) (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing))
    (let ((s3-0 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
      (set! (-> s3-0 prim-core collide-as) (collide-kind enemy))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set! (-> s3-0 prim-core offense) (collide-offense indestructible))
      (set-vector! (-> s3-0 local-sphere) 0.0 2457.6 0.0 2457.6)
      (set-root-prim! s4-0 s3-0))
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> this collide-info) s4-0))
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton this *muse-sg* '())
  (logclear! (-> this mask) (process-mask actor-pause))
  (init-defaults! this *muse-nav-enemy-info*)
  (set! (-> this max-path-index) (the float (+ (-> this path curve num-cverts) -1)))
  (set! (-> this current-path-index) 0.0)
  (set! (-> this prev-path-index) 0.0)
  (set! (-> this dest-path-index) 0.0)
  (set! (-> this player-path-index) 0.0)
  (eval-path-curve-div! (-> this path) (-> this dest-point) (-> this current-path-index) 'interp)
  (set! (-> this collide-info trans quad) (-> this dest-point quad))
  (set! (-> this nav nearest-y-threshold) 20480.0)
  (set-vector! (-> this neck twist-max) 8192.0 8192.0 0.0 1.0)
  (set! (-> this neck up) (the-as uint 0))
  (set! (-> this neck nose) (the-as uint 1))
  (set! (-> this neck ear) (the-as uint 2))
  (set! (-> this neck max-dist) 102400.0)
  (set! (-> this neck ignore-angle) 16384.0)
  (set! (-> this anim)
        (new 'static 'spool-anim :name "muse-victory" :index 9 :parts 2 :command-list '((1 blackout 0) (219 blackout 60))))
  (set! (-> this victory-anim) (fuel-cell-pick-anim this))
  (go muse-v4-catchable-idle)
  (none))


;;///////////FISHERMAN//////////////;;
(deftype fisherman-v4 (nav-enemy)
  ((root               collide-shape-moving :override)
   (current-path-index float)
   (prev-path-index    float)
   (dest-path-index    float)
   (player-path-index  float)
   (max-path-index     float)
   (sprint-distance    float)
   (interacted?        symbol)
   (dest-point         vector :inline)
   (anim               spool-anim)
   (victory-anim       spool-anim)
   (old-target-pos     transformq :inline)
   (chat-time          time-frame))
  (:states
   fisherman-v4-idle
   ))

(defskelgroup *fisher-sg*
  fisher
  fisher-lod0-jg
  fisher-idle-more-often-ja
  ((fisher-lod0-mg (meters 20)) (fisher-lod1-mg (meters 40)) (fisher-lod2-mg (meters 999999)))
  :bounds (static-spherem 0 -6 0 14)
  :shadow fisher-shadow-mg)

(defstate fisherman-v4-idle (fisherman-v4)
  :trans
  (behavior ()
    (when (and *target*
               (>= 51920.0 (vector-vector-distance (-> self root trans) (-> *target* control trans))))
      (when (hud-hidden?)
        (let ((gp-0 (new 'stack 'font-context *font-default-matrix* 32 160 0.0
                         (font-color default)
                         (font-flags shadow kerning))))
          (set! (-> gp-0 flags) (font-flags shadow kerning large))
          (print-game-text (lookup-text! *common-text* (text-id press-to-talk) #f)
                           gp-0 #f 128 22)))
      (when (and (cpad-pressed? 0 circle)
           (time-elapsed? (-> self chat-time) (seconds 5)))
  (set-time! (-> self chat-time))
  (play-sound-file "sound_replacements/fishies.mp3" 100))))
  :code
 (behavior ()
        (loop
        (let* ((f30-0 5.0)
               (v1-9 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
               (v1-10 (the-as number (logior #x3f800000 v1-9))))
          (countdown (gp-1 (+ (the int (* f30-0 (+ -1.0 (the-as float v1-10)))) 5))
            (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
            (until (ja-done? 0)
              ;;(process-taskable-method-43 self)
              (suspend)
              (ja :num! (seek!)))))
        (when (ja-group? fisher-idle-more-often-ja)
          (ja-no-eval :group! fisher-idle-more-often-ja :num! (seek!) :frame-num 0.0)
          (until (ja-done? 0)
            ;;(process-taskable-method-43 self)
            (suspend)
            (ja :num! (seek!)))))
      )
  :post ja-post)

(defmethod init-from-entity! ((this fisherman-v4) (arg0 entity-actor) )
  (stack-size-set! (-> this main-thread) 512)
  (logior! (-> this mask) (process-mask enemy))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s4-0 prim-core collide-as) (collide-kind enemy))
      (set! (-> s4-0 collide-with) (collide-kind target))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set! (-> s4-0 prim-core offense) (collide-offense indestructible))
      (set-vector! (-> s4-0 local-sphere) 6144.0 0.0 4096.0 14336.0)
      (set-root-prim! s5-0 s4-0)
      (let ((s2-0 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
        (set! (-> s2-0 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-0 collide-with) (collide-kind target))
        (set! (-> s2-0 prim-core action) (collide-action solid))
        (set! (-> s2-0 prim-core offense) (collide-offense indestructible))
        ;;(set! (-> s2-0 transform-index) arg0)
        (set-vector! (-> s2-0 local-sphere) 0.0 0.0 0.0 6553.6)
        (append-prim s4-0 s2-0))
      (let ((s3-1 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
        (set! (-> s3-1 prim-core collide-as) (collide-kind enemy))
        (set! (-> s3-1 collide-with) (collide-kind target))
        (set! (-> s3-1 prim-core action) (collide-action solid))
        (set! (-> s3-1 prim-core offense) (collide-offense indestructible))
        (set! (-> s3-1 transform-index) 57)
        (set-vector! (-> s3-1 local-sphere) 0.0 8096.0 0.0 8096.0)
        (append-prim s4-0 s3-1)))
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (backup-collide-with-as s5-0)
    (set! (-> this root) s5-0))
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton this *fisher-sg* '())
  (logclear! (-> this mask) (process-mask actor-pause))
  (init-defaults! this *muse-nav-enemy-info*)
  (go fisherman-v4-idle)
  (none))



;;///////////yellowsage//////////////;;
(deftype yellowsage-v4 (nav-enemy)
  ((root               collide-shape-moving :override)
   (current-path-index float)
   (prev-path-index    float)
   (dest-path-index    float)
   (player-path-index  float)
   (max-path-index     float)
   (sprint-distance    float)
   (interacted?        symbol)
   (dest-point         vector :inline)
   (anim               spool-anim)
   (victory-anim       spool-anim)
   (old-target-pos     transformq :inline)
   (chat-time          time-frame))
  (:states
   yellowsage-v4-idle
   ))

(defskelgroup *yellowsage-sg*
  yellowsage
  yellowsage-lod0-jg
  yellowsage-yellowsage-idle-ja
  ((yellowsage-lod0-mg (meters 20)) (yellowsage-lod1-mg (meters 999999)))
  :bounds (static-spherem 0 0 0 14)
  :shadow yellowsage-shadow-mg)

(defstate yellowsage-v4-idle (yellowsage-v4)
  :trans
  (behavior ()
    (when (and *target*
               (>= 51920.0 (vector-vector-distance (-> self root trans) (-> *target* control trans))))
      (when (hud-hidden?)
        (let ((gp-0 (new 'stack 'font-context *font-default-matrix* 32 160 0.0
                         (font-color default)
                         (font-flags shadow kerning))))
          (set! (-> gp-0 flags) (font-flags shadow kerning large))
          (print-game-text (lookup-text! *common-text* (text-id press-to-talk) #f)
                           gp-0 #f 128 22)))
      (when (and (cpad-pressed? 0 circle)
           (time-elapsed? (-> self chat-time) (seconds 5)))
  (set-time! (-> self chat-time))
  (play-sound-file "sound_replacements/muskratstew.mp3" 500))))
  :code
 (behavior ()
        (loop
        (let* ((f30-0 5.0)
               (v1-9 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
               (v1-10 (the-as number (logior #x3f800000 v1-9))))
          (countdown (gp-1 (+ (the int (* f30-0 (+ -1.0 (the-as float v1-10)))) 5))
            (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
            (until (ja-done? 0)
              ;;(process-taskable-method-43 self)
              (suspend)
              (ja :num! (seek!)))))
        (when (ja-group? *yellowsage-sg*)
          (ja-no-eval :group! *yellowsage-sg* :num! (seek!) :frame-num 0.0)
          (until (ja-done? 0)
            ;;(process-taskable-method-43 self)
            (suspend)
            (ja :num! (seek!)))))
      )
  :post ja-post)

(defmethod init-from-entity! ((this yellowsage-v4) (arg0 entity-actor))
  (stack-size-set! (-> this main-thread) 512)
  (logior! (-> this mask) (process-mask enemy))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s4-0 prim-core collide-as) (collide-kind enemy))
      (set! (-> s4-0 collide-with) (collide-kind target))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set! (-> s4-0 prim-core offense) (collide-offense indestructible))
      (set-vector! (-> s4-0 local-sphere) 6144.0 0.0 4096.0 14336.0)
      (set-root-prim! s5-0 s4-0)
      (let ((s2-0 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
        (set! (-> s2-0 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-0 collide-with) (collide-kind target))
        (set! (-> s2-0 prim-core action) (collide-action solid))
        (set! (-> s2-0 prim-core offense) (collide-offense indestructible))
        ;;(set! (-> s2-0 transform-index) arg0)
        (set-vector! (-> s2-0 local-sphere) 0.0 0.0 0.0 6553.6)
        (append-prim s4-0 s2-0))
      (let ((s3-1 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
        (set! (-> s3-1 prim-core collide-as) (collide-kind enemy))
        (set! (-> s3-1 collide-with) (collide-kind target))
        (set! (-> s3-1 prim-core action) (collide-action solid))
        (set! (-> s3-1 prim-core offense) (collide-offense indestructible))
        (set! (-> s3-1 transform-index) 57)
        (set-vector! (-> s3-1 local-sphere) 0.0 14096.0 0.0 14096.0)
        (append-prim s4-0 s3-1))
        )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (backup-collide-with-as s5-0)
    (set! (-> this root) s5-0))
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton this *yellowsage-sg* '())
  (logclear! (-> this mask) (process-mask actor-pause))
  (init-defaults! this *muse-nav-enemy-info*)
  (go yellowsage-v4-idle)
  (none))

















  ;;////////////////////STEAMCAP////////////////;;

(deftype steam-cap-control-pt-v4 (structure)
  ((trans  vector :inline)
   (transv vector :inline)))


(deftype steam-cap-v4 (process-drawable)
  ((root              collide-shape-moving :override)
   (do-burst?         symbol)
   (do-falling-sound? symbol)
   (do-landing-sound? symbol)
   (begin-travel-up   float)
   (begin-travel-down float)
   (sync              sync-info :inline)
   (part2             sparticle-launch-control)
   (part3             sparticle-launch-control)
   (down              vector :inline)
   (up                vector :inline)
   (control-pt        steam-cap-control-pt 3 :inline))
  (:methods
   (steam-cap-method-20 (_type_) none)
   (steam-cap-method-21 (_type_) quaternion))
  (:states
   steam-cap-idle-v4))

(defpartgroup group-steam-cap-sides
  :id 441
  :bounds (static-bspherem 0 0 0 10)
  :parts
  ((sp-item 1718 :fade-after (meters 100) :falloff-to (meters 160) :period (seconds 0.6) :length (seconds 0.25))
   (sp-item 1719 :fade-after (meters 100) :falloff-to (meters 160) :period (seconds 0.6) :length (seconds 0.25) :offset 60)
   (sp-item 1720
            :fade-after (meters 100)
            :falloff-to (meters 160)
            :period (seconds 0.6)
            :length (seconds 0.25)
            :offset 120)
   (sp-item 1721 :fade-after (meters 100) :falloff-to (meters 160) :period (seconds 0.6) :length (seconds 0.25))
   (sp-item 1722 :fade-after (meters 100) :falloff-to (meters 160) :period (seconds 0.6) :length (seconds 0.25) :offset 60)
   (sp-item 1723
            :fade-after (meters 100)
            :falloff-to (meters 160)
            :period (seconds 0.6)
            :length (seconds 0.25)
            :offset 120)
   (sp-item 1724 :fade-after (meters 60) :falloff-to (meters 60) :period (seconds 0.6) :length (seconds 0.25) :offset 120)))

(defpart 1724
  :init-specs
  ((:num 1.0)
   (:rot-x 5)
   (:r 4096.0)
   (:g 2867.2)
   (:b 3276.8)
   (:vel-y (meters 0.016666668) (meters 0.033333335))
   (:accel-y (meters 0.000033333334))
   (:friction 0.92 0.02)
   (:timer (seconds 1))
   (:flags (aux-list))
   (:next-time (seconds 0.5))
   (:next-launcher 1725)
   (:conerot-x (degrees 90))
   (:conerot-y (degrees 0) (degrees 360))
   (:conerot-radius (meters 2.5))))

(defpart 1725
  :init-specs ((:fade-b -2.7306666)))

(defpart 1718
  :init-specs
  ((:texture (bigpuff effects))
   (:num 0.0 2.0)
   (:y (meters -0.5))
   (:scale-x (meters 0.5) (meters 1.5))
   (:rot-z (degrees 0) (degrees 360))
   (:scale-y :copy scale-x)
   (:r 128.0)
   (:g 128.0)
   (:b 128.0)
   (:a 0.0 16.0)
   (:vel-y (meters 0.016666668) (meters 0.033333335))
   (:scalevel-x (meters 0.01))
   (:rotvel-z (degrees -0.2) (degrees 0.4))
   (:scalevel-y :copy scalevel-x)
   (:fade-a 0.10666667)
   (:accel-y (meters 0.000033333334))
   (:friction 0.92 0.02)
   (:timer (seconds 1))
   (:flags (bit2 bit3))
   (:next-time (seconds 0.5))
   (:next-launcher 1726)
   (:conerot-x (degrees 90))
   (:conerot-y (degrees 0) (degrees 120))
   (:conerot-radius (meters 2.5))))

(defpart 1721
  :init-specs
  ((:texture (bigpuff effects))
   (:num 0.0 2.0)
   (:y (meters -0.5))
   (:scale-x (meters 0.5) (meters 1.5))
   (:rot-z (degrees 0) (degrees 360))
   (:scale-y :copy scale-x)
   (:r 128.0)
   (:g 128.0)
   (:b 128.0)
   (:a 0.0 16.0)
   (:vel-y (meters 0.016666668) (meters 0.033333335))
   (:scalevel-x (meters 0.01))
   (:rotvel-z (degrees -0.2) (degrees 0.4))
   (:scalevel-y :copy scalevel-x)
   (:fade-a 0.10666667)
   (:accel-y (meters 0.000033333334))
   (:friction 0.92 0.02)
   (:timer (seconds 1))
   (:flags (bit2))
   (:next-time (seconds 0.5))
   (:next-launcher 1726)
   (:conerot-x (degrees 90))
   (:conerot-y (degrees 0) (degrees 120))
   (:conerot-radius (meters 2.5))))

(defpart 1719
  :init-specs
  ((:texture (bigpuff effects))
   (:num 0.0 2.0)
   (:y (meters -0.5))
   (:scale-x (meters 0.5) (meters 1.5))
   (:rot-z (degrees 0) (degrees 360))
   (:scale-y :copy scale-x)
   (:r 128.0)
   (:g 128.0)
   (:b 128.0)
   (:a 0.0 16.0)
   (:vel-y (meters 0.016666668) (meters 0.033333335))
   (:scalevel-x (meters 0.01))
   (:rotvel-z (degrees -0.2) (degrees 0.4))
   (:scalevel-y :copy scalevel-x)
   (:fade-a 0.10666667)
   (:accel-y (meters 0.000033333334))
   (:friction 0.92 0.02)
   (:timer (seconds 1))
   (:flags (bit2 bit3))
   (:next-time (seconds 0.5))
   (:next-launcher 1726)
   (:conerot-x (degrees 90))
   (:conerot-y (degrees 120) (degrees 120))
   (:conerot-radius (meters 2.5))))

(defpart 1722
  :init-specs
  ((:texture (bigpuff effects))
   (:num 0.0 2.0)
   (:y (meters -0.5))
   (:scale-x (meters 0.5) (meters 1.5))
   (:rot-z (degrees 0) (degrees 360))
   (:scale-y :copy scale-x)
   (:r 128.0)
   (:g 128.0)
   (:b 128.0)
   (:a 0.0 16.0)
   (:vel-y (meters 0.016666668) (meters 0.033333335))
   (:scalevel-x (meters 0.01))
   (:rotvel-z (degrees -0.2) (degrees 0.4))
   (:scalevel-y :copy scalevel-x)
   (:fade-a 0.10666667)
   (:accel-y (meters 0.000033333334))
   (:friction 0.92 0.02)
   (:timer (seconds 1))
   (:flags (bit2))
   (:next-time (seconds 0.5))
   (:next-launcher 1726)
   (:conerot-x (degrees 90))
   (:conerot-y (degrees 120) (degrees 120))
   (:conerot-radius (meters 2.5))))

(defpart 1720
  :init-specs
  ((:texture (bigpuff effects))
   (:num 0.0 2.0)
   (:y (meters -0.5))
   (:scale-x (meters 0.5) (meters 1.5))
   (:rot-z (degrees 0) (degrees 360))
   (:scale-y :copy scale-x)
   (:r 128.0)
   (:g 128.0)
   (:b 128.0)
   (:a 0.0 16.0)
   (:vel-y (meters 0.016666668) (meters 0.033333335))
   (:scalevel-x (meters 0.01))
   (:rotvel-z (degrees -0.2) (degrees 0.4))
   (:scalevel-y :copy scalevel-x)
   (:fade-a 0.10666667)
   (:accel-y (meters 0.000033333334))
   (:friction 0.92 0.02)
   (:timer (seconds 1))
   (:flags (bit2 bit3))
   (:next-time (seconds 0.5))
   (:next-launcher 1726)
   (:conerot-x (degrees 90))
   (:conerot-y (degrees 240) (degrees 120))
   (:conerot-radius (meters 2.5))))

(defpart 1723
  :init-specs
  ((:texture (bigpuff effects))
   (:num 0.0 2.0)
   (:y (meters -0.5))
   (:scale-x (meters 0.5) (meters 1.5))
   (:rot-z (degrees 0) (degrees 360))
   (:scale-y :copy scale-x)
   (:r 128.0)
   (:g 128.0)
   (:b 128.0)
   (:a 0.0 16.0)
   (:vel-y (meters 0.016666668) (meters 0.033333335))
   (:scalevel-x (meters 0.01))
   (:rotvel-z (degrees -0.2) (degrees 0.4))
   (:scalevel-y :copy scalevel-x)
   (:fade-a 0.10666667)
   (:accel-y (meters 0.000033333334))
   (:friction 0.92 0.02)
   (:timer (seconds 1))
   (:flags (bit2))
   (:next-time (seconds 0.5))
   (:next-launcher 1726)
   (:conerot-x (degrees 90))
   (:conerot-y (degrees 240) (degrees 120))
   (:conerot-radius (meters 2.5))))

(defpart 1726
  :init-specs ((:fade-a -0.21333334)))

(defpartgroup group-steam-cap-plume
  :id 442
  :bounds (static-bspherem 0 0 0 32)
  :parts
  ((sp-item 1727 :fade-after (meters 120) :falloff-to (meters 160))
   (sp-item 1728 :fade-after (meters 120) :falloff-to (meters 160))
   (sp-item 1729 :fade-after (meters 60) :falloff-to (meters 60))
   (sp-item 1730 :fade-after (meters 60) :falloff-to (meters 60) :flags (start-dead))))

(defpartgroup group-steam-cap-plume-spread
  :id 443
  :bounds (static-bspherem 0 0 0 32)
  :parts
  ((sp-item 1731 :fade-after (meters 120) :falloff-to (meters 160))
   (sp-item 1732 :fade-after (meters 120) :falloff-to (meters 160))))

(defpart 1730
  :init-specs
  ((:num 0.4)
   (:rot-x 5)
   (:r 6144.0)
   (:g 2867.2)
   (:b 3276.8)
   (:vel-y (meters 0.016666668) (meters 0.033333335))
   (:accel-y (meters 0.000033333334))
   (:friction 0.94 0.02)
   (:timer (seconds 1))
   (:flags (aux-list))
   (:next-time (seconds 0.5))
   (:next-launcher 1725)
   (:conerot-x (degrees 90))
   (:conerot-y (degrees 0) (degrees 360))
   (:conerot-radius (meters 2.5))))

(defpart 1732
  :init-specs
  ((:texture (bigpuff effects))
   (:num 0.5)
   (:y (meters -0.5))
   (:scale-x (meters 1) (meters 1))
   (:rot-z (degrees 0) (degrees 360))
   (:scale-y :copy scale-x)
   (:r 128.0)
   (:g 128.0)
   (:b 128.0)
   (:a 16.0 32.0)
   (:vel-y (meters 0.026666667) (meters 0.026666667))
   (:scalevel-x (meters 0.013333334))
   (:rotvel-z (degrees -0.2) (degrees 0.4))
   (:scalevel-y :copy scalevel-x)
   (:accel-y (meters 0.000033333334))
   (:friction 0.92 0.02)
   (:timer (seconds 1))
   (:flags (bit2 bit3))
   (:next-time (seconds 0.5))
   (:next-launcher 1735)
   (:conerot-x (degrees 90) (degrees 15))
   (:conerot-y (degrees 0) (degrees 360))
   (:conerot-radius (meters 0.5))))

(defpart 1731
  :init-specs
  ((:texture (bigpuff effects))
   (:num 0.5)
   (:y (meters -0.5))
   (:scale-x (meters 1) (meters 1))
   (:rot-z (degrees 0) (degrees 360))
   (:scale-y :copy scale-x)
   (:r 128.0)
   (:g 128.0)
   (:b 128.0)
   (:a 16.0 32.0)
   (:vel-y (meters 0.026666667) (meters 0.026666667))
   (:scalevel-x (meters 0.013333334))
   (:rotvel-z (degrees -0.2) (degrees 0.4))
   (:scalevel-y :copy scalevel-x)
   (:accel-y (meters 0.000033333334))
   (:friction 0.92 0.02)
   (:timer (seconds 1))
   (:flags (bit2))
   (:next-time (seconds 0.5))
   (:next-launcher 1735)
   (:conerot-x (degrees 90) (degrees 15))
   (:conerot-y (degrees 0) (degrees 360))
   (:conerot-radius (meters 0.5))))

(defpart 1735
  :init-specs ((:fade-a -0.32)))

(defpart 1727
  :init-specs
  ((:texture (bigpuff effects))
   (:num 0.5 0.5)
   (:x (meters 0) (meters 1))
   (:y (meters -1))
   (:scale-x (meters 2) (meters 2))
   (:rot-z (degrees 0) (degrees 360))
   (:scale-y :copy scale-x)
   (:r 128.0)
   (:g 128.0)
   (:b 128.0)
   (:a 16.0 16.0)
   (:vel-y (meters 0.053333335))
   (:rotvel-z (degrees -0.2) (degrees 0.4))
   (:accel-y (meters 0.00066666666))
   (:timer (seconds 0.51))
   (:flags (bit2))
   (:conerot-x (degrees 0) (degrees 15))
   (:rotate-y (degrees 0) (degrees 360))))

(defpart 1728
  :init-specs
  ((:texture (bigpuff effects))
   (:num 0.5 0.5)
   (:x (meters 0) (meters 0.5))
   (:y (meters -1))
   (:scale-x (meters 2) (meters 2))
   (:rot-z (degrees 0) (degrees 360))
   (:scale-y :copy scale-x)
   (:r 128.0)
   (:g 128.0)
   (:b 128.0)
   (:a 32.0 32.0)
   (:vel-y (meters 0.053333335))
   (:rotvel-z (degrees -0.2) (degrees 0.4))
   (:accel-y (meters 0.00066666666))
   (:timer (seconds 0.51))
   (:flags (bit2 bit3))
   (:rotate-y (degrees 0) (degrees 360))))

(defpart 1729
  :init-specs
  ((:num 0.5)
   (:x (meters 0.5) (meters 0.5))
   (:rot-x 5)
   (:r 6144.0)
   (:g 2457.6)
   (:b 3276.8)
   (:vel-y (meters 0.053333335))
   (:timer (seconds 0.51))
   (:flags (aux-list))
   (:rotate-y (degrees 0) (degrees 360))))

(defskelgroup *steam-cap-sg*
  steam-cap
  steam-cap-lod0-jg
  steam-cap-idle-ja
  ((steam-cap-lod0-mg (meters 999999)))
  :bounds (static-spherem 0 0 0 3))

(defmethod steam-cap-method-20 ((this steam-cap-v4))
  (when *target*
    (let* ((a1-0 (target-pos 0))
           (f0-0 (-> a1-0 y)))
      (when (and (>= f0-0 (+ -8192.0 (-> this down y)))
                 (and (>= (+ -4096.0 (-> this root trans y)) f0-0) (zero? (-> this root riders num-riders))))
        (let ((f0-1 (vector-vector-xz-distance-squared (-> this down) a1-0)))
          (when (>= 104857600.0 f0-1)
            (let ((s5-0 (>= 37748736.0 f0-1)))
              (when (not s5-0)
                (when (>= (- (-> this root trans y) (-> this down y)) 3072.0)
                  (let ((a1-1 (new 'stack-no-clear 'vector)))
                    (set! (-> a1-1 x) (the-as float 1))
                    (set! (-> a1-1 y) (the-as float #f))
                    (if (find-overlapping-shapes (-> this root) (the-as overlaps-others-params a1-1)) (set! s5-0 #t)))))
              (if s5-0 (send-event *target* 'shove #f (static-attack-info ((shove-up (meters 0.5)) (shove-back (meters 1.5))))))))))))
  (none))

(defmethod steam-cap-method-21 ((this steam-cap-v4))
  (when (task-complete? *game-info* (game-task brume-restore-power)) ;; added temp task ready for yellow eggtop. this stops steamcaps from moving until that task is complete
  (local-vars (at-0 int) (at-1 int) (s5-0 symbol))
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf))
    (init-vf0-vector)
    (let ((f0-0 (get-current-phase (-> this sync))))
      #t
      (cond
        ((< f0-0 (-> this begin-travel-up))
         (let ((f30-0 (/ f0-0 (-> this begin-travel-up))))
           (set! s5-0 #t)
           (dotimes (s4-0 3)
             (let ((s3-0 (-> this control-pt s4-0)))
               (when (= (-> s3-0 trans y) (-> this down y))
                 (set! (-> this do-burst?) #t)
                 (let ((a0-2 (+ (the int (* 60.0 (- 1.0 f30-0))) 3)))
                   (if (zero? (rand-vu-int-count a0-2)) (+! (-> s3-0 transv y) (* (rand-vu-float-range 40960.0 57344.0) f30-0)))))))
           (let ((a0-4 (+ (the int (* 60.0 (- 1.0 f30-0))) 1)))
             (if (zero? (rand-vu-int-count a0-4)) (spawn (-> this part) (-> this down))))))
        ((< f0-0 (-> this begin-travel-down))
         (let ((f30-1 (/ (- f0-0 (-> this begin-travel-up)) (- (-> this begin-travel-down) (-> this begin-travel-up)))))
           (set! s5-0 #f)
           (set! (-> this do-falling-sound?) #t)
           (when (-> this do-burst?)
             ;;(sound-play "sunk-top-rises") ;; annoying sound
             (set! (-> this do-burst?) #f)
             (spawn (-> this part) (-> this down))
             (spawn (-> this part) (-> this down))
             (spawn (-> this part) (-> this down))
             (spawn (-> this part) (-> this down)))
           (when (< f30-1 0.94)
             (spawn (-> this part2) (-> this down))
             (let ((a1-8 (new 'stack-no-clear 'vector)))
               (set! (-> a1-8 quad) (-> this root trans quad))
               (+! (-> a1-8 y) -3072.0)
               (spawn (-> this part3) a1-8)))))
        (else
         (set! s5-0 #t)
         (when (-> this do-falling-sound?)
           (set! (-> this do-falling-sound?) #f)
           (sound-play "sunk-top-falls")))))
    (dotimes (s4-3 3)
      (let ((s2-0 (-> this control-pt s4-3))
            (s3-3 (new 'stack-no-clear 'vector)))
        (set! (-> s3-3 quad) (-> s2-0 trans quad))
        (cond
          (s5-0
           (+! (-> s2-0 transv y) (* -819200.0 (seconds-per-frame)))
           (let ((a1-10 s3-3)
                 (v1-42 s3-3)
                 (a0-21 (new 'stack-no-clear 'vector)))
             (.lvf vf1 (&-> (-> s2-0 transv) quad))
             (let ((f0-17 (seconds-per-frame))) (.mov at-0 f0-17))
             (.mov vf2 at-0)
             (.mov.vf vf1 vf0 :mask #b1000)
             (.mul.x.vf vf1 vf1 vf2 :mask #b111)
             (.svf (&-> a0-21 quad) vf1)
             (vector+! a1-10 v1-42 a0-21))
           (when (< (-> s3-3 y) (-> this down y))
             (when (-> this do-landing-sound?)
               (set! (-> this do-landing-sound?) #f)
               (sound-play "sunk-top-lands"))
             (set! (-> s3-3 y) (-> this down y))
             (let ((f0-20 (-> s2-0 transv y)))
               (when (< f0-20 0.0)
                 (let ((f0-22 (* 0.3 (- f0-20))))
                   (set! (-> s2-0 transv y) f0-22)
                   (if (< 7782.4 f0-22) (sound-play "sunk-top-lands" :vol 60)))))))
          (else
           (set! (-> this do-landing-sound?) #t)
           (let ((f0-24 (* 0.000048828126 (- (-> this up y) (-> s2-0 trans y)))))
             (cond
               ((< 1.0 f0-24) (set! f0-24 1.0))
               ((< f0-24 -1.0) (set! f0-24 -1.0)))
             (+! (-> s2-0 transv y) (* 819200.0 (seconds-per-frame) f0-24))
             (let ((f1-24 (-> s2-0 transv y)))
               (when (< 122880.0 (fabs f1-24))
                 (if (>= f1-24 0.0) (set! (-> s2-0 transv y) 122880.0) (set! (-> s2-0 transv y) -122880.0))))
             (let ((a1-14 s3-3)
                   (v1-61 s3-3)
                   (a0-26 (new 'stack-no-clear 'vector)))
               (.lvf vf1 (&-> (-> s2-0 transv) quad))
               (let ((f1-27 (seconds-per-frame))) (.mov at-1 f1-27))
               (.mov vf2 at-1)
               (.mov.vf vf1 vf0 :mask #b1000)
               (.mul.x.vf vf1 vf1 vf2 :mask #b111)
               (.svf (&-> a0-26 quad) vf1)
               (vector+! a1-14 v1-61 a0-26))
             (let ((f1-29 (- (-> this up y) (-> s3-3 y)))
                   (v1-62 (>= f0-24 0.0)))
               (when (!= v1-62 (>= f1-29 0.0))
                 (let ((f0-26 (-> s2-0 transv y)))
                   (when (< 40960.0 (fabs f0-26))
                     (if (>= f0-26 0.0) (set! (-> s2-0 transv y) 40960.0) (set! (-> s2-0 transv y) -40960.0))))
                 (set! (-> s2-0 transv y) (* 0.8 (-> s2-0 transv y))))))))
        (set! (-> s2-0 trans quad) (-> s3-3 quad))))
    (let ((f0-31 0.0))
      (dotimes (v1-71 3)
        (+! f0-31 (-> this control-pt v1-71 trans y)))
      (let ((f0-32 (/ f0-31 3))
            (a1-16 (new 'stack-no-clear 'vector)))
        (set! (-> a1-16 quad) (-> this root trans quad))
        (set! (-> a1-16 y) f0-32)
        (move-to-point! (-> this root) a1-16)))
    (let ((v1-77 (new 'stack-no-clear 'vector))
          (a0-35 (new 'stack-no-clear 'vector))
          (s5-1 (new 'stack-no-clear 'vector)))
      (vector-! v1-77 (the-as vector (&-> this stack 176)) (the-as vector (-> this control-pt)))
      (vector-! a0-35 (the-as vector (&-> this stack 208)) (the-as vector (-> this control-pt)))
      (vector-cross! s5-1 v1-77 a0-35)
      (vector-normalize! s5-1 1.0)
      (forward-up-nopitch->quaternion (-> this root quat) (vector-z-quaternion! (new-stack-vector0) (-> this root quat)) s5-1)))))

(defstate steam-cap-idle-v4 (steam-cap-v4)
  :trans rider-trans
  :code
    (behavior ()
      (loop
        (steam-cap-method-20 self)
        (steam-cap-method-21 self)
        (suspend)))
  :post rider-post)

(defmethod relocate ((this steam-cap-v4) (offset int))
  (if (nonzero? (-> this part2)) (&+! (-> this part2) offset))
  (if (nonzero? (-> this part3)) (&+! (-> this part3) offset))
  (call-parent-method this offset))

(defmethod deactivate ((this steam-cap-v4))
  (if (nonzero? (-> this part2)) (kill-and-free-particles (-> this part2)))
  (if (nonzero? (-> this part3)) (kill-and-free-particles (-> this part3)))
  ((method-of-type process-drawable deactivate) this)
  (none))

(defmethod init-from-entity! ((this steam-cap-v4) (arg0 entity-actor))
  (local-vars (sv-16 res-tag))
  (logior! (-> this mask) (process-mask platform))
  (let ((s4-0 (new 'process 'collide-shape-moving this (collide-list-enum hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) default-collision-reaction)
    (set! (-> s4-0 no-reaction) (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing))
    (alloc-riders s4-0 1)
    (let ((s3-0 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s3-0 prim-core collide-as) (collide-kind ground-object))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core action) (collide-action solid rider-plat-sticky))
      (set! (-> s3-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s3-0 transform-index) 4)
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 12288.0)
      (set-root-prim! s4-0 s3-0))
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> this root) s4-0))
  (set! (-> this do-burst?) #f)
  (set! (-> this do-falling-sound?) #f)
  (set! (-> this do-landing-sound?) #f)
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton this *steam-cap-sg* '())
  (logior! (-> this skel status) (janim-status inited))
  (ja-channel-set! 1)
  (let ((s4-1 (-> this skel root-channel 0)))
    (joint-control-channel-group-eval! s4-1 (the-as art-joint-anim (-> this draw art-group data 2)) num-func-identity)
    (set! (-> s4-1 frame-num) 0.0))
  (update-transforms! (-> this root))
  (load-params! (-> this sync) this (the-as uint 1800) 0.0 0.15 0.15)
  (let ((f30-0 0.4)
        (f28-0 0.9))
    (set! sv-16 (new 'static 'res-tag))
    (let ((v1-36 (res-lump-data arg0 'percent (pointer float) :tag-ptr (& sv-16))))
      (when v1-36
        (set! f30-0 (-> v1-36 0))
        (set! f28-0 (-> v1-36 1))
        (if (>= 0.01 f30-0) (set! f30-0 0.01))
        (if (>= 0.01 f28-0) (set! f28-0 0.01))
        (if (>= f30-0 f28-0) (set! f28-0 (+ 0.01 f30-0)))
        (when (>= f30-0 1.0)
          (set! f28-0 (* 0.9 (/ f28-0 f30-0)))
          (set! f30-0 0.9))))
    (set! (-> this begin-travel-up) f30-0)
    (set! (-> this begin-travel-down) f28-0))
  (set! (-> this down quad) (-> this root trans quad))
  (set! (-> this up quad) (-> this root trans quad))
  (+! (-> this up y) 40960.0)
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 441) this))
  (set! (-> this part2) (create-launch-control (-> *part-group-id-table* 442) this))
  (set! (-> this part3) (create-launch-control (-> *part-group-id-table* 443) this))
  (vector-reset! (-> this root transv))
  (let ((s5-1 (new 'stack-no-clear 'vector))
        (f30-1 0.0))
    (dotimes (s4-2 3)
      (let ((s3-1 (-> this control-pt s4-2)))
        (set-vector! s5-1 0.0 0.0 10240.0 1.0)
        (vector-rotate-around-y! s5-1 s5-1 f30-1)
        (set! f30-1 (+ 21845.334 f30-1))
        (vector+! (-> s3-1 trans) s5-1 (-> this root trans))
        (vector-reset! (-> s3-1 transv)))))
  (go steam-cap-idle-v4)
  (none))

;;///////BEAM////

(defpart 1000
  :init-specs
  ((:texture (citadel-shield effects))
   (:birth-func 'birth-func-set-quat)
   (:num 1.0)
   (:scale-x (meters 3) (meters 0.5))
   (:scale-y (meters 5.6))
   (:r 128.0 32.0)
   (:g 128.0 32.0)
   (:b 0.0 0.0)
   (:a 128.0)
   (:timer (seconds 0.017))
   (:flags (bit2 bit3 bit14 left-multiply-quat))))

(defun draw-eco-beam-v4 ((arg0 vector) (arg1 vector))
  (when (line-in-view-frustum? arg0 arg1)
    (let ((s2-1 (vector-! (new 'stack-no-clear 'vector) arg1 arg0))
          (gp-1 (new 'stack-no-clear 'vector))
          (s4-0 (new 'stack-no-clear 'vector))
          (s5-0 (new 'stack-no-clear 'quaternion)))
      (vector+*! gp-1 arg0 s2-1 0.5)
      (vector-normalize-copy! s4-0 s2-1 1.0)
      (set! (-> *part-id-table* 1000 init-specs 4 initial-valuef) (vector-length s2-1))
      (forward-up->quaternion s5-0 s4-0 *y-vector*)
      (dotimes (s4-1 3)
        (quaternion-rotate-local-z! s5-0 s5-0 10922.667)
        (quaternion-copy! *particle-quat* s5-0)
        (launch-particles :system *sp-particle-system-3d* (-> *part-id-table* 1000) gp-1)
        )))
  0
  (none))

(deftype beam-vent (process-drawable)
  ((beam-start vector :inline)
   (beam-end   vector :inline)
   (beam-part  basic))
  (:states beam-vent-idle))

(defstate beam-vent-idle (beam-vent)
  :code
    (behavior ()
      ;; Continuously draw the eco beam every frame
      (loop
        (when (-> self beam-part)
          (draw-eco-beam-v4 (-> self beam-start) (-> self beam-end)))
        (suspend))))

(defmethod init-from-entity! ((this beam-vent) (arg0 entity-actor))

  (set! (-> this root) (new 'process 'trsqv))
  (process-drawable-from-entity! this arg0)

  ;; Beam source and end positions
  (set! (-> this beam-start quad) (-> this root trans quad))
  (set! (-> this beam-start y)  (-> this beam-start y))
  (set! (-> this beam-end quad) (-> this root trans quad))
  (set! (-> this beam-end y) (+ 11981920.0 (-> this beam-end y))) ; Far above actor

  ;; Set the beam particle (borrowed from ecoclaw)
  ;;(set! (-> this beam-part) (-> *part-group-id-table* 2750))

  ;; Start idle state
  (when (task-complete? *game-info* (game-task brume-restore-power))(go beam-vent-idle))
  (none))


  ;;;game-task specific plats;;;
  (deftype brume-plat (plat)
  ((timings     float 64))) ;; inline array of floats


(defmethod init-from-entity! ((this brume-plat) (arg0 entity-actor))
  (when (task-complete? *game-info* (game-task mount-platformbutton))(logior! (-> this mask) (process-mask platform))
  (baseplat-method-24 this)
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton this (get-unlit-skel this) '())
  (logior! (-> this skel status) (janim-status inited))
  (update-transforms! (-> this root))
  (baseplat-method-21 this)
  (baseplat-method-25 this)
  (load-params! (-> this sync) this (the-as uint 0) 0.0 0.15 0.15)
  (set! (-> this fact) (new 'process 'fact-info this (pickup-type eco-pill-random) (-> *FACT-bank* default-pill-inc)))
  (set! (-> this path) (new 'process 'curve-control this 'path -1000000000.0))

  ;; read path timing data from res-lump
  ;; look up the curve data
  (let* ((tag (new 'static 'res-tag))
         (data (res-lump-data arg0 'timings pointer :tag-ptr (& tag) :time -1000000000.0)))
    (when data
      ;; success, we got some data
      (dotimes (idx (-> this path curve num-cverts))
        (set! (-> this timings idx) (-> (the-as (pointer float) data) idx)))))

  (logior! (-> this path flags) (path-control-flag display draw-line draw-point draw-text))
  (set! (-> this sound-id) (new-sound-id))
  (cond
    ((logtest? (-> this path flags) (path-control-flag not-found))
     (set! (-> this path-pos) 0.0)
     (let ((a0-14 this)) (baseplat-method-26 a0-14) (go (method-of-object this plat-startup) a0-14)))
    ((> (-> this sync period) 0)
     (set! (-> this path-pos)
           (if (logtest? (-> this fact options) (fact-options wrap-phase))
             (get-current-phase (-> this sync))
             (get-current-phase-with-mirror (-> this sync))))
     (eval-path-curve! (-> this path) (-> this root trans) (-> this path-pos) 'interp)
     (let ((a0-18 this)) (baseplat-method-26 a0-18) (go (method-of-object this plat-startup) a0-18)))
    (else
     (set! (-> this path-pos) 0.0)
     (eval-path-curve! (-> this path) (-> this root trans) (-> this path-pos) 'interp)
     (let ((a0-20 this)) (baseplat-method-26 a0-20) (go (method-of-object this plat-startup) a0-20)))))
  (none))

;;elevator;;
(deftype brume-elevator (plat-button)
  ((play-at-top-going-up-camera? symbol)
   (teleport-if-below-y          float)
   (teleport-if-above-y          float)))


(defskelgroup *sunken-elevator-sg*
  sunken-elevator
  sunken-elevator-lod0-jg
  sunken-elevator-pressed-ja
  ((sunken-elevator-lod0-mg (meters 999999)))
  :bounds (static-spherem 0 -1 0 6.6))

(defmethod should-teleport? ((this brume-elevator))
  (let ((f0-0 (-> (camera-pos) y)))
    (case (-> this path-pos)
      ((0.0) (if (< f0-0 (-> this teleport-if-below-y)) (return #t)))
      ((1.0) (if (< (-> this teleport-if-above-y) f0-0) (return #t)))))
  #f)

(defstate plat-button-pressed (brume-elevator)
  :virtual #t
  :enter
    (behavior ()
      (let ((t9-0 (-> (method-of-type plat-button plat-button-pressed) enter))) (if t9-0 (t9-0)))
      (case (-> self path-pos)
        ((0.0)
         ;;(load-state-want-levels 'preundg 'brume) moved to load boundary
         ;;(load-state-want-display-level 'preundg 'display) moved to load boundary

         0)
        ((1.0)
         ))))

(defstate plat-button-move-upward (brume-elevator)
  :virtual #t
  :enter
    (behavior ()
      (let ((t9-0 (-> (method-of-type plat-button plat-button-move-upward) enter))) (if t9-0 (t9-0)))
      (set! (-> self play-at-top-going-up-camera?) #t))
  :trans
    (behavior ()
      (let ((t9-0 (-> (method-of-type plat-button plat-button-move-upward) trans))) (if t9-0 (t9-0)))
      (when (and (-> self play-at-top-going-up-camera?) (>= 0.14 (-> self path-pos)))
        (set! *teleport* #t)
        (set! (-> self play-at-top-going-up-camera?) #f)
        (load-state-want-display-level 'sunken 'special)
        )))

(defstate plat-button-move-downward (brume-elevator)
  :virtual #t
  :trans
    (behavior ()
      (let ((s5-0 (new 'stack-no-clear 'vector))
            (gp-0 (new 'stack-no-clear 'vector)))
        (set! *teleport* #t)
        (set! (-> s5-0 quad) (-> self root trans quad))
        (call-parent-state-handler trans)
        (vector-! gp-0 (-> self root trans) s5-0)
        )))

(defmethod can-target-move? ((this brume-elevator))
  (set! (-> this play-at-top-going-up-camera?) #f)
  (let ((s5-0 (new 'stack-no-clear 'vector)))
    (eval-path-curve! (-> this path) s5-0 0.4 'interp)
    (set! (-> this teleport-if-above-y) (-> s5-0 y))
    (eval-path-curve! (-> this path) s5-0 0.6 'interp)
    (set! (-> this teleport-if-below-y) (-> s5-0 y)))
  (none))

(defmethod plat-button-method-27 ((this brume-elevator))
  (ja-channel-set! 1)
  (cond
    ((can-activate? this)
     (let ((s5-0 (-> this skel root-channel 0)))
       (joint-control-channel-group-eval! s5-0 (the-as art-joint-anim (-> this draw art-group data 2)) num-func-identity)
       (set! (-> s5-0 frame-num) 0.0)))
    (else
     (let ((s5-1 (-> this skel root-channel 0)))
       (joint-control-channel-group-eval! s5-1 (the-as art-joint-anim (-> this draw art-group data 2)) num-func-identity)
       (set! (-> s5-1 frame-num) (the float (+ (-> (the-as art-joint-anim (-> this draw art-group data 2)) data 0 length) -1))))))
  (ja-post)
  (update-transforms! (-> this root))
  (none))

(defmethod plat-button-method-31 ((this brume-elevator))
  (initialize-skeleton this *sunken-elevator-sg* '())
  0
  (none))


;;lantern;;


(defpartgroup group-v4-flamepot-half
  :id 750
  :bounds (static-bspherem 0 5 0 6)
  :parts
  ((sp-item 3145 :fade-after (meters 180) :falloff-to (meters 180))
   (sp-item 3146 :fade-after (meters 100) :falloff-to (meters 100))
   (sp-item 3147 :fade-after (meters 50) :falloff-to (meters 60))))

(defpart 3145
  :init-specs
  ((:texture (bigpuff effects))
   (:num 0.35 0.25)
   (:x (meters -0.1) (meters 0.1))
   (:y (meters -0.25))
   (:z (meters -0.1) (meters 0.1))
   (:scale-x (meters 0.6) (meters 0.6))
   (:rot-z (degrees 0) (degrees 360))
   (:scale-y :copy scale-x)
   (:r 128.0 128.0)
   (:g 32.0 64.0)
   (:a 96.0)
   (:vel-y (meters 0.005) (meters 0.004166667))
   (:rotvel-z (degrees -0.99999994) (degrees 1.9999999))
   (:fade-g 0.32)
   (:fade-b 0.32)
   (:fade-a -0.5416667)
   (:accel-y (meters -0.000013333334))
   (:timer (seconds 0.3) (seconds 0.197))
   (:flags (bit2 bit3 bit14))
   (:conerot-x (degrees -8) 4 (degrees 4))
   (:conerot-y (degrees -180) (degrees 360))
   (:conerot-z (degrees 15))
   (:conerot-radius (meters 0) (meters 0.5))))

(defpart 3146
  :init-specs
  ((:texture (bigpuff effects))
   (:num 0.06 0.06)
   (:x (meters -0.5) (meters 1))
   (:y (meters -0.25))
   (:z (meters -0.5) (meters 1))
   (:scale-x (meters 2) (meters 1))
   (:rot-z (degrees 0) (degrees 360))
   (:scale-y :copy scale-x)
   (:r 128.0)
   (:g 64.0)
   (:b 0.0)
   (:a 20.0 12.0)
   (:vel-y (meters 0.006666667) (meters 0.0033333334))
   (:scalevel-x (meters 0.0055555557))
   (:rotvel-z (degrees -0.2) (degrees 0.4))
   (:scalevel-y :copy scalevel-x)
   (:fade-a -0.0627451)
   (:accel-y (meters -0.0001))
   (:timer (seconds 2))
   (:flags (bit2 bit14))
   (:next-time (seconds 0.5) (seconds 0.197))
   (:next-launcher 3151)
   (:conerot-x (degrees -4) 4 (degrees 2))
   (:conerot-y (degrees -180) (degrees 360))
   (:conerot-radius (meters 0) (meters 0.5))))

(defpart 3147
  :init-specs
  ((:num 0.15)
   (:x (meters 0.4))
   (:rot-x 5)
   (:r 4096.0)
   (:g 2867.2)
   (:b 3072.0)
   (:vel-y (meters 0.01))
   (:timer (seconds 0.6))
   (:flags (aux-list))
   (:next-time (seconds 0.4))
   (:next-launcher 3150)
   (:rotate-y (degrees 0) (degrees 360))))

(defpart 3150
  :init-specs ((:fade-b -3.4133334)))

(defpart 3151
  :init-specs ((:fade-g 0.53333336) (:fade-b 1.0666667) (:next-time (seconds 0.4)) (:next-launcher 3152)))

(defpart 3152
  :init-specs ((:fade-g 0.0) (:fade-b 0.0)))


;;sparks;;
(defpartgroup group-v4-sages-machine
  :id 780 ;; id changed to test for crashes
  :bounds (static-bspherem 0 0 0 8)
  :parts
  ((sp-item 1199 :fade-after (meters 40) :period (seconds 2.56) :length (seconds 0.035) :binding 1197)
   (sp-item 1199 :fade-after (meters 40) :period (seconds 3.655) :length (seconds 0.035) :binding 1198)
   (sp-item 1199 :fade-after (meters 40) :period (seconds 7.125) :length (seconds 0.035) :binding 1197)
   (sp-item 1197 :fade-after (meters 40) :flags (start-dead))
   (sp-item 1197 :fade-after (meters 40) :flags (start-dead))
   (sp-item 1198 :fade-after (meters 40) :flags (start-dead))
   (sp-item 1200 :fade-after (meters 40) :period (seconds 1) :length (seconds 0.017))
   (sp-item 1200 :fade-after (meters 40) :period (seconds 1.567) :length (seconds 0.017))
   (sp-item 1200 :fade-after (meters 40) :period (seconds 2.045) :length (seconds 0.017))
   (sp-item 1200 :fade-after (meters 40) :period (seconds 4.455) :length (seconds 0.017))
   (sp-item 1201 :fade-after (meters 40) :falloff-to (meters 40))
   (sp-item 1202 :fade-after (meters 40))
   (sp-item 1203 :fade-after (meters 40) :falloff-to (meters 50))
   (sp-item 1204 :fade-after (meters 40) :falloff-to (meters 50))))

(defpart 1201
  :init-specs
  ((:texture (hotdot effects))
   (:num 0.5 1.0)
   (:x (meters -0.75))
   (:y (meters -0.8))
   (:z (meters 2.6))
   (:scale-x (meters 0.2) (meters 0.4))
   (:scale-y :copy scale-x)
   (:r 32.0 32.0)
   (:g 32.0 32.0)
   (:b 128.0)
   (:a 64.0 64.0)
   (:scalevel-x (meters -0.00055555557))
   (:scalevel-y :copy scalevel-x)
   (:fade-r -0.06)
   (:fade-a -0.18)
   (:timer (seconds 0.1) (seconds 1.497))
   (:flags (bit2 bit3 bit14))
   (:conerot-x (degrees 0) (degrees 180))
   (:conerot-y (degrees -120) (degrees 210))
   (:conerot-radius (meters 0.3))))

(defpart 1202
  :init-specs
  ((:texture (starflash effects))
   (:num 1.0)
   (:x (meters -0.75))
   (:y (meters -0.8))
   (:z (meters 2.6))
   (:scale-x (meters 2) (meters 2.4))
   (:scale-y :copy scale-x)
   (:r 32.0 64.0)
   (:g 32.0 64.0)
   (:b 128.0 128.0)
   (:a 32.0 64.0)
   (:scalevel-x (meters -0.00055555557))
   (:scalevel-y :copy scalevel-x)
   (:timer (seconds 0.017))
   (:flags (bit2 bit3 bit14))))

(defpart 1200
  :init-specs
  ((:texture (lightning effects))
   (:num 1.0 0.5)
   (:x (meters -0.7))
   (:y (meters -0.7))
   (:z (meters 2.6))
   (:scale-x (meters 4) (meters 3))
   (:rot-x 4)
   (:rot-z (degrees 60) (degrees 60))
   (:scale-y (meters 0.4) (meters 0.4))
   (:r 64.0)
   (:g 64.0)
   (:b 128.0)
   (:a 128.0)
   (:fade-a -1.6)
   (:timer (seconds 0.3))
   (:flags (bit2 bit3 bit14))
   (:next-time (seconds 0.035))
   (:next-launcher 1205)))

(defpart 1205
  :init-specs ((:r 64.0) (:g 64.0) (:fade-r -1.0666667) (:fade-g -1.0666667) (:fade-a -2.1333334)))

(defpart 1203
  :init-specs
  ((:texture (bigpuff effects))
   (:num 0.2 0.4)
   (:x (meters -1.25))
   (:y (meters 0))
   (:z (meters 0))
   (:scale-x (meters 1) (meters 1))
   (:rot-z (degrees 0) (degrees 360))
   (:scale-y :copy scale-x)
   (:r 64.0 32.0)
   (:g 64.0)
   (:b 64.0 32.0)
   (:a 0.0)
   (:vel-y (meters 0.0033333334) (meters 0.0033333334))
   (:scalevel-x (meters 0.0022222223))
   (:rotvel-z (degrees -0.4) (degrees 0.8))
   (:scalevel-y :copy scalevel-x)
   (:fade-a 0.53333336)
   (:timer (seconds 2))
   (:flags (bit2))
   (:next-time (seconds 0.1) (seconds 0.297))
   (:next-launcher 1206)
   (:conerot-x (degrees -4) 4 (degrees 2))
   (:conerot-y (degrees -180) (degrees 360))
   (:conerot-radius (meters 0) (meters 0.5))))

(defpart 1206
  :init-specs ((:fade-r -0.053333335) (:fade-g -0.053333335) (:fade-b -0.053333335) (:fade-a -0.10666667) (:friction 0.95)))

(defpart 1204
  :init-specs
  ((:texture (bigpuff effects))
   (:num 0.2 0.8)
   (:x (meters -0.7))
   (:y (meters -0.7))
   (:z (meters 2.6))
   (:scale-x (meters 0.5) (meters 0.25))
   (:rot-z (degrees 0) (degrees 360))
   (:scale-y :copy scale-x)
   (:r 64.0 32.0)
   (:g 64.0 32.0)
   (:b 64.0)
   (:a 32.0 32.0)
   (:vel-y (meters 0.0033333334) (meters 0.0033333334))
   (:scalevel-x (meters 0.0022222223))
   (:rotvel-z (degrees -0.4) (degrees 0.8))
   (:scalevel-y :copy scalevel-x)
   (:fade-r -0.053333335)
   (:fade-g -0.053333335)
   (:fade-b -0.053333335)
   (:fade-a -0.10666667)
   (:friction 0.99)
   (:timer (seconds 2))
   (:flags (bit2))
   (:conerot-x (degrees -4) 4 (degrees 2))
   (:conerot-y (degrees -180) (degrees 360))
   (:conerot-radius (meters 0))))

(defpart 1199
  :init-specs
  ((:texture (starflash effects))
   (:num 1.0)
   (:scale-x (meters 1))
   (:scale-y :copy scale-x)
   (:r 64.0)
   (:g 64.0)
   (:b 64.0)
   (:a 128.0)
   (:fade-a -6.4)
   (:timer (seconds 0.067))
   (:flags (bit2 bit3))
   (:conerot-x (degrees 0) (degrees 180))
   (:conerot-y (degrees -60) (degrees 120))
   (:conerot-radius (meters 1.1))))

(defpart 1197
  :init-specs
  ((:texture (hotdot effects))
   (:num 2.0 8.0)
   (:sound (static-sound-spec "spark" :num 0.1 :volume 100.0))
   (:scale-x (meters 0.1) (meters 0.1))
   (:scale-y :copy scale-x)
   (:r 128.0 128.0)
   (:g 128.0)
   (:b 64.0)
   (:a 32.0 96.0)
   (:vel-y (meters 0.013333334) (meters 0.08))
   (:scalevel-x (meters -0.00016666666))
   (:scalevel-y :copy scalevel-x)
   (:fade-g -0.2)
   (:fade-b -0.2)
   (:fade-a -0.4)
   (:accel-y (meters -0.0016666667))
   (:friction 0.92)
   (:timer (seconds 1))
   (:flags (bit2 bit14))
   (:conerot-x (degrees 0) (degrees 120))
   (:conerot-y (degrees -180) (degrees 180))))

(defpart 1198
  :init-specs
  ((:texture (hotdot effects))
   (:num 2.0 6.0)
   (:sound (static-sound-spec "spark" :num 0.1 :volume 100.0))
   (:scale-x (meters 0.1) (meters 0.1))
   (:scale-y :copy scale-x)
   (:r 128.0 128.0)
   (:g 128.0)
   (:b 64.0)
   (:a 32.0 96.0)
   (:vel-y (meters 0.013333334) (meters 0.08))
   (:scalevel-x (meters -0.00016666666))
   (:scalevel-y :copy scalevel-x)
   (:fade-g -0.2)
   (:fade-b -0.2)
   (:accel-y (meters -0.002))
   (:friction 0.92)
   (:timer (seconds 4))
   (:flags (bit2 bit14))
   (:userdata 91750.4)
   (:func 'check-drop-level-sagehut2)
   (:conerot-x (degrees 0) (degrees 120))
   (:conerot-y (degrees -180) (degrees 180))))

;; warp gate

(defpartgroup group-brume-warpgate
  :id 150
  :bounds (static-bspherem 0 0 0 8)
  :parts ((sp-item 767 :fade-after (meters 60) :falloff-to (meters 60))
    (sp-item 768 :fade-after (meters 60) :falloff-to (meters 100) :binding 765)
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 765 :flags (bit1 start-dead launch-asap))
    (sp-item 769 :fade-after (meters 60) :falloff-to (meters 100) :binding 766)
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 766 :flags (bit1 start-dead launch-asap))
    (sp-item 770 :fade-after (meters 100) :flags (is-3d))
    )
  )

(defpart 770
  :init-specs ((:texture (new 'static 'texture-id :index #x3 :page #x2))
    (:num 0.5)
    (:x (meters -11.6666667))
    (:scale-x (meters 5))
    (:rot-x (degrees 90))
    (:rot-z (degrees 15))
    (:scale-y :copy scale-x)
    (:r 0.0 32.0)
    (:g 0.0 32.0)
    (:b 64.0 64.0)
    (:a 0.0 64.0)
    (:timer (seconds 0.035))
    (:flags (bit3 bit14))
    )
  )

(defpart 769
  :init-specs ((:texture (new 'static 'texture-id :index #xf :page #x2))
    (:num 0.25)
    (:x (meters -2))
    (:scale-x (meters 0.25))
    (:scale-y :copy scale-x)
    (:g 128.0)
    (:a 0.0)
    (:vel-x (meters 0.0033333334))
    (:timer (seconds 2))
    (:flags (bit3 bit14))
    (:rotate-y (degrees -105))
    )
  )

(defpart 766
  :init-specs ((:texture (new 'static 'texture-id :index #x4 :page #x2))
    (:num 1.0)
    (:x (meters -11.0666667)) ;; THE ROTATION FIELD.
    (:y (meters 4))
    (:z (meters 5.4) (meters 1))
    (:scale-x (meters 0.2) (meters 0.1))
    (:scale-y :copy scale-x)
    (:r 0.0 32.0)
    (:g 0.0 32.0)
    (:b 64.0 64.0)
    (:a 0.0)
    (:omega 0.0 65536.0)
    (:vel-x (meters 0))
    (:vel-z (meters 0))
    (:fade-a 0.16)
    (:accel-x (meters 0.0002962963))
    (:accel-z (meters -0.00018333334))
    (:timer (seconds 2))
    (:flags (bit2 bit3 bit7 bit14))
    )
  )

(defpart 767
  :init-specs ((:num 3.0 3.0)
    (:x (meters -0.5))
    (:rot-x 5)
    (:r 4096.0)
    (:g 3481.6)
    (:b 3481.6)
    (:vel-y (meters -0.026666667) (meters -0.02))
    (:fade-b 2.968116)
    (:timer (seconds 0.23))
    (:flags (aux-list))
    (:conerot-x (degrees 0) (degrees 360))
    (:conerot-radius (meters 4) (meters 3))
    (:rotate-y (degrees -105))
    )
  )

(defpart 768
  :init-specs ((:texture (new 'static 'texture-id :index #xf :page #x2))
    (:num 1.0)
    (:scale-x (meters 0.25))
    (:scale-y :copy scale-x)
    (:g 128.0)
    (:a 0.0)
    (:accel-x (meters 0.000016666667))
    (:timer (seconds 2.3))
    (:flags (bit3 bit14))
    (:rotate-y (degrees -105))
    )
  )

(defpart 765
  :init-specs ((:texture (new 'static 'texture-id :page #x2))
    (:num 1.0)
    (:x (meters -11.6666667)) ;; THIS IS THE ROTATION FIELD
    (:y (meters 4))
    (:z (meters 2.4))
    (:scale-x (meters 1.1) (meters 0.6))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 0.0 32.0)
    (:g 0.0 32.0)
    (:b 64.0 64.0)
    (:a 8.0 32.0)
    (:omega 0.0 65536.0)
    (:vel-x (meters -0.0044444446))
    (:vel-z (meters -0.0034999999))
    (:rotvel-z (degrees 0) (degrees 1.2))
    (:fade-a 0.21333334)
    (:accel-x (meters 0.0010370371))
    (:timer (seconds 2.3))
    (:flags (bit2 bit3 bit7 bit14))
    )
  )
