;;-*-Lisp-*-
(in-package goal)
(require "engine/common-obs/generic-obs.gc")
(require "engine/util/sync-info.gc")
(require "engine/common-obs/path.gc")





  ;;eggtop yellow new
  (deftype cave-eggtop (process-drawable)
  ((root        collide-shape-moving :override)
   (spawn-trans vector :inline)
   (play-sound? symbol))
  (:states
   cave-eggtop-activate
   cave-eggtop-idle-down
   cave-eggtop-idle-up))


(defskelgroup *preundg-eggtop-sg*
  eggtop
  eggtop-lod0-jg
  eggtop-idle-ja
  ((eggtop-lod0-mg (meters 999999)))
  :bounds (static-spherem 0 0 0 4))

(defpartgroup group-cave-yellow-eco-room-open
  :id 510
  :bounds (static-bspherem 0 -6 0 8)
  :parts
  ((sp-item 3990 :fade-after (meters 110))
   (sp-item 3991 :fade-after (meters 110))
   (sp-item 3992 :fade-after (meters 110))
   (sp-item 3993 :fade-after (meters 110))
   (sp-item 3994 :fade-after (meters 110))))

(defpartgroup group-cave-yellow-eco-room-activate
  :id 511
  :duration (seconds 3)
  :bounds (static-bspherem 0 -6 0 8)
  :parts ((sp-item 3994) (sp-item 3994) (sp-item 3995 :flags (bit1) :period (seconds 4) :length (seconds 0.05))))

(defpart 3995
  :init-specs
  ((:texture (flare effects))
   (:num 30.0)
   (:y (meters -4))
   (:scale-x (meters 20) (meters 10))
   (:rot-x 4)
   (:rot-z (degrees 0) (degrees 360))
   (:scale-y (meters 5) (meters 2))
   (:r 127.0)
   (:g 127.0)
   (:b 0.0 16.0)
   (:a 0.0)
   (:rotvel-z (degrees -0.05) (degrees 0.1))
   (:fade-a 0.85333335)
   (:timer (seconds 2))
   (:flags (bit2 bit3 left-multiply-quat))
   (:next-time (seconds 0.25))
   (:next-launcher 3996)))

(defpart 3996
  :init-specs ((:fade-a 0.0) (:next-time (seconds 0.75)) (:next-launcher 3997)))

(defpart 3997
  :init-specs ((:fade-a -0.14222223)))

(defpart 3990
  :init-specs
  ((:texture (hotdot effects))
   (:num 1.0)
   (:y (meters -4))
   (:scale-x (meters 10) (meters 2))
   (:scale-y (meters 8) (meters 2))
   (:r 255.0)
   (:g 255.0)
   (:b 0.0 64.0)
   (:a 128.0 128.0)
   (:timer (seconds 0.017))
   (:flags (bit2 bit3))))

(defpart 3991
  :init-specs
  ((:texture (hotdot effects))
   (:num 1.0)
   (:y (meters -4))
   (:scale-x (meters 3) (meters 2))
   (:scale-y :copy scale-x)
   (:r 128.0)
   (:g 128.0)
   (:b 128.0)
   (:a 128.0 128.0)
   (:timer (seconds 0.017))
   (:flags (bit2 bit3))))

(defpart 3992
  :init-specs
  ((:texture (lightning effects))
   (:num 0.5 1.0)
   (:y (meters -4))
   (:scale-x (meters 3) (meters 3))
   (:rot-x 4)
   (:rot-z (degrees -30) (degrees 60))
   (:scale-y (meters 0.7) (meters 0.4))
   (:r 128.0)
   (:g 128.0)
   (:b 64.0)
   (:a 128.0)
   (:fade-a -1.6)
   (:timer (seconds 0.3))
   (:flags (bit2 bit3))
   (:next-time (seconds 0.035))
   (:next-launcher 3998)))

(defpart 3998
  :init-specs ((:r 64.0) (:g 64.0) (:fade-r -1.0) (:fade-g -1.0) (:fade-a -2.0)))

(defpart 3993
  :init-specs
  ((:texture (lightning effects))
   (:num 0.5 1.0)
   (:y (meters -4))
   (:scale-x (meters 3) (meters 3))
   (:rot-x 4)
   (:rot-z (degrees 150) (degrees 60))
   (:scale-y (meters 0.7) (meters 0.4))
   (:r 128.0)
   (:g 128.0)
   (:b 64.0)
   (:a 128.0)
   (:fade-a -1.6)
   (:timer (seconds 0.3))
   (:flags (bit2 bit3))
   (:next-time (seconds 0.035))
   (:next-launcher 3998)))

(defpart 3994
  :init-specs
  ((:texture (lightning effects))
   (:num 1.0 1.0)
   (:y (meters -6.5) (meters 1))
   (:scale-x (meters 6) (meters 2))
   (:rot-x 4)
   (:rot-z (degrees -140) (degrees 100.00001))
   (:scale-y (meters 0.7) (meters 0.4))
   (:r 128.0)
   (:g 128.0)
   (:b 64.0)
   (:a 128.0)
   (:fade-a -1.6)
   (:timer (seconds 0.3))
   (:flags (bit2 bit3))
   (:next-time (seconds 0.035))
   (:next-launcher 3998)
   (:conerot-x (degrees 90))
   (:conerot-y (degrees 80) (degrees 200.00002))
   (:conerot-radius (meters 4))))

(defstate cave-eggtop-idle-up (cave-eggtop)
  :event
    (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
      (case message
        (('notify)
         (case (-> block param 0)
           (('pickup)
            (if (type-type? (-> proc type) fuel-cell) (save-reminder (get-task-control (-> self entity extra perm task)) 1 4)))))))
  :trans
    (behavior ()
      (if (and (not (-> self child)) (task-complete? *game-info* (-> self entity extra perm task))) (go cave-eggtop-activate))
      (spawn (-> self part) (-> self root trans))
      (update! (-> self sound)))
  :code
    (behavior ()
      (ja-channel-push! 1 0)
      (ja :group! snow-eggtop-idle-ja :num! min)
      (transform-post)
      (loop
        (logior! (-> self mask) (process-mask sleep-code))
        (suspend))))

(defstate cave-eggtop-activate (cave-eggtop)
  :event
    (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
      (case message
        (('notify)
         (when (= (-> proc type) snowcam)
           (cond
             ((= (-> block param 0) 'die) (if *target* (+! (-> *target* control trans y) 1024.0)) (go cave-eggtop-idle-down))
             ((= (-> block param 0) 'cut) (stop! (-> self sound)) (set! (-> self play-sound?) #f) #f))))))
  :enter
    (behavior ()
      (logclear! (-> self mask) (process-mask actor-pause))
      (process-entity-status! self (entity-perm-status bit-3) #t)
      (set! (-> self play-sound?) #t))
  :exit
    (behavior ()
      (stop! (-> self sound))
      (logior! (-> self mask) (process-mask actor-pause))
      (process-entity-status! self (entity-perm-status bit-3) #f))
  :trans rider-trans
  :code
    (behavior ()
      (process-spawn part-tracker
                     :init
                     part-tracker-init
                     (-> *part-group-id-table* 511)
                     -1
                     #f
                     #f
                     #f
                     (-> self root trans)
                     :to
                     *entity-pool*)
      (change-sound! (-> self sound) (static-sound-name "snw-eggtop-seq"))
      (save-reminder (get-task-control (-> self entity extra perm task)) 2 4)
      (ja-no-eval :group! snow-eggtop-idle-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (if (-> self play-sound?) (update! (-> self sound)))
        (suspend)
        (ja :num! (seek!)))
      (level-hint-spawn (text-id snow-eggtop-resolution) "sksp0360" (the-as entity #f) *entity-pool* (game-task brume-restore-power))
      (set-time! (-> self state-time))
      (until (time-elapsed? (-> self state-time) (seconds 1.1))
        (if (-> self play-sound?) (update! (-> self sound)))
        (suspend))
      (process-entity-status! self (entity-perm-status complete) #t)
      (let ((a0-18 (-> self entity))) (if (and a0-18 (= self (-> a0-18 extra process))) (entity-task-complete-on a0-18)))
      (send-event (ppointer->process (-> *hud-parts* fuel-cell)) 'show)
      (go cave-eggtop-idle-down)
      (loop
        (if (-> self play-sound?) (update! (-> self sound)))
        (suspend)))
  :post rider-post)

(defstate cave-eggtop-idle-down (cave-eggtop)
  :code
    (behavior ()
      (process-entity-status! self (entity-perm-status complete) #t)
      (let ((a0-1 (-> self entity))) (if (and a0-1 (= self (-> a0-1 extra process))) (entity-task-complete-on a0-1)))
      (ja-channel-push! 1 0)
      (ja :group! snow-eggtop-idle-ja :num! max)
      (transform-post)
      (logior! (-> self mask) (process-mask sleep-code))
      (suspend)
      0))

(defmethod init-from-entity! ((this cave-eggtop) (arg0 entity-actor))
  (let ((s4-0 (new 'process 'collide-shape-moving this (collide-list-enum hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) default-collision-reaction)
    (set! (-> s4-0 no-reaction) (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing))
    (alloc-riders s4-0 1)
    (let ((s3-0 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s3-0 prim-core collide-as) (collide-kind ground-object))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core action) (collide-action solid rider-plat-sticky))
      (set! (-> s3-0 prim-core offense) (collide-offense indestructible))
      (set! (-> s3-0 transform-index) 4)
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 -7372.8 18022.4)
      (set-root-prim! s4-0 s3-0))
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> this root) s4-0))
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton this *preundg-eggtop-sg* '())
  (logior! (-> this skel status) (janim-status inited))
  (set! (-> this spawn-trans quad) (-> this root trans quad))
  (+! (-> this root trans y) -2662.4)
  (update-transforms! (-> this root))
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 510) this))
  (set! (-> this sound) (new 'process 'ambient-sound (static-sound-spec "electric-loop" :fo-max 40) (-> this root trans)))
  (cond
    ((task-complete? *game-info* (-> this entity extra perm task)) (go cave-eggtop-idle-down))
    (else
     (let ((a0-17 (new 'stack-no-clear 'vector)))
       (set! (-> a0-17 quad) (-> this root trans quad))
       (+! (-> a0-17 y) 3072.0)
       (birth-pickup-at-point a0-17
                              (pickup-type fuel-cell)
                              (the float (-> this entity extra perm task))
                              #f
                              this
                              (the-as fact-info #f)))
     (go cave-eggtop-idle-up)))
  (none))


;; // lanterns //

(deftype abandon-part (part-spawner) ())

(defpartgroup group-abandon-candle
  :id 776
  :bounds (static-bspherem 0 10 0 12)
  :parts
  ((sp-item 1797 :fade-after (meters 60) :falloff-to (meters 60))
   (sp-item 1798 :fade-after (meters 60) :falloff-to (meters 60))))

(defpart 1797
  :init-specs
  ((:texture (hotdot effects))
   (:num 1.0)
   (:y (meters -0.08) (meters 0.02))
   (:scale-x (meters 0.2) (meters 0.2))
   (:scale-y :copy scale-x)
   (:r 128.0 64.0)
   (:g 64.0 64.0)
   (:b 0.0 32.0)
   (:a 32.0 32.0)
   (:vel-x (meters 0) (meters 0.00016666666))
   (:vel-z (meters 0) (meters 0.00016666666))
   (:scalevel-x (meters -0.0016666667))
   (:scalevel-y :copy scalevel-x)
   (:fade-g -0.7111111)
   (:accel-y (meters 0.00026666667) (meters 0.00006666667))
   (:timer (seconds 0.2) (seconds 0.097))
   (:flags (bit3))))

(defpart 1798
  :init-specs
  ((:texture (starflash effects))
   (:num 1.0)
   (:y (meters -0.04))
   (:scale-x (meters 0.5) (meters 0.5))
   (:rot-z (degrees 0) (degrees 360))
   (:scale-y :copy scale-x)
   (:r 128.0 64.0)
   (:g 64.0 64.0)
   (:b 0.0 32.0)
   (:a 8.0 16.0)
   (:vel-x (meters 0) (meters 0.00016666666))
   (:vel-z (meters 0) (meters 0.00016666666))
   (:scalevel-x (meters -0.0016666667))
   (:scalevel-y :copy scalevel-x)
   (:fade-g -0.7111111)
   (:fade-a -0.8)
   (:accel-y (meters 0.00026666667) (meters 0.00006666667))
   (:timer (seconds 0.085))
   (:flags (bit2 bit3))))


;; flamepots ;;

(defpartgroup group-abandon-flamepot-half
  :id 267
  :bounds (static-bspherem 0 5 0 6)
  :parts
  ((sp-item 1145 :fade-after (meters 180) :falloff-to (meters 180))
   (sp-item 1146 :fade-after (meters 100) :falloff-to (meters 100))
   (sp-item 1147 :fade-after (meters 50) :falloff-to (meters 60))))

(defpart 1145
  :init-specs
  ((:texture (bigpuff effects))
   (:num 0.35 0.25)
   (:x (meters -0.1) (meters 0.1))
   (:y (meters -0.25))
   (:z (meters -0.1) (meters 0.1))
   (:scale-x (meters 0.6) (meters 0.6))
   (:rot-z (degrees 0) (degrees 360))
   (:scale-y :copy scale-x)
   (:r 128.0 128.0)
   (:g 32.0 64.0)
   (:a 96.0)
   (:vel-y (meters 0.005) (meters 0.004166667))
   (:rotvel-z (degrees -0.99999994) (degrees 1.9999999))
   (:fade-g 0.32)
   (:fade-b 0.32)
   (:fade-a -0.5416667)
   (:accel-y (meters -0.000013333334))
   (:timer (seconds 0.3) (seconds 0.197))
   (:flags (bit2 bit3 bit14))
   (:conerot-x (degrees -8) 4 (degrees 4))
   (:conerot-y (degrees -180) (degrees 360))
   (:conerot-z (degrees 15))
   (:conerot-radius (meters 0) (meters 0.5))))

(defpart 1146
  :init-specs
  ((:texture (bigpuff effects))
   (:num 0.06 0.06)
   (:x (meters -0.5) (meters 1))
   (:y (meters -0.25))
   (:z (meters -0.5) (meters 1))
   (:scale-x (meters 2) (meters 1))
   (:rot-z (degrees 0) (degrees 360))
   (:scale-y :copy scale-x)
   (:r 128.0)
   (:g 64.0)
   (:b 0.0)
   (:a 20.0 12.0)
   (:vel-y (meters 0.006666667) (meters 0.0033333334))
   (:scalevel-x (meters 0.0055555557))
   (:rotvel-z (degrees -0.2) (degrees 0.4))
   (:scalevel-y :copy scalevel-x)
   (:fade-a -0.0627451)
   (:accel-y (meters -0.0001))
   (:timer (seconds 2))
   (:flags (bit2 bit14))
   (:next-time (seconds 0.5) (seconds 0.197))
   (:next-launcher 1151)
   (:conerot-x (degrees -4) 4 (degrees 2))
   (:conerot-y (degrees -180) (degrees 360))
   (:conerot-radius (meters 0) (meters 0.5))))

(defpart 1147
  :init-specs
  ((:num 0.15)
   (:x (meters 0.4))
   (:rot-x 5)
   (:r 4096.0)
   (:g 2867.2)
   (:b 3072.0)
   (:vel-y (meters 0.01))
   (:timer (seconds 0.6))
   (:flags (aux-list))
   (:next-time (seconds 0.4))
   (:next-launcher 1150)
   (:rotate-y (degrees 0) (degrees 360))))

(defpart 1150
  :init-specs ((:fade-b -3.4133334)))

(defpart 1151
  :init-specs ((:fade-g 0.53333336) (:fade-b 1.0666667) (:next-time (seconds 0.4)) (:next-launcher 1152)))

(defpart 1152
  :init-specs ((:fade-g 0.0) (:fade-b 0.0)))




;; driller kill tracker code ;;

(deftype abandon-driller-lurker (process-drawable)
  ((root-overeride          collide-shape-moving :overlay-at root)
   (hit-player?             symbol)
   (played-drill-sound?     symbol)
   (mode                    uint64)
   (path-u                  float)
   (path-units-per-meter    float)
   (path-speed              float)
   (targ-path-speed         float)
   (path-dir                float)
   (path-ry                 float)
   (facing-ry               float)
   (drill-rz                float)
   (drill-speed             float)
   (up-blend                float)
   (player-path-u           float)
   (ambient-drilling-u      float)
   (timeout                 int32)
   (neck                    joint-mod)
   (drill                   joint-mod)
   (sound2                  ambient-sound)
   (last-update-time        time-frame)
   (last-player-path-u-time time-frame)
   (started-chasing-time    time-frame)
   (hit-player-time         time-frame)
   (player-attack-id        uint64)
   (driller-id              uint) ;; for driller in abandon
   )
  (:methods
   (abandon-driller-lurker-method-20 (_type_ symbol target) symbol)
   (abandon-driller-lurker-method-21 (_type_) none)
   (abandon-driller-lurker-method-22 (_type_) none)
   (abandon-driller-lurker-method-23 (_type_) float)
   (abandon-driller-lurker-method-24 (_type_) symbol)
   (abandon-driller-lurker-method-25 (_type_) symbol)
   (abandon-driller-lurker-method-26 (_type_) symbol)
   (abandon-driller-lurker-method-27 (_type_) object))
  (:states
   abandon-driller-lurker-attack
   (abandon-driller-lurker-chase symbol)
   abandon-driller-lurker-debug-play-anims
   abandon-driller-lurker-die
   abandon-driller-lurker-idle-drilling
   abandon-driller-lurker-jammed-standing
   abandon-driller-lurker-patrol
   abandon-driller-lurker-patrol-pause))


(defskelgroup *abandon-driller-lurker-sg*
  driller-lurker
  driller-lurker-lod0-jg
  -1
  ((driller-lurker-lod0-mg (meters 20)) (driller-lurker-lod1-mg (meters 40)) (driller-lurker-lod2-mg (meters 999999)))
  :bounds (static-spherem 0 1.5 0 7.75)
  :longest-edge (meters 2.3)
  :shadow driller-lurker-shadow-mg)

(define *driller-lurker-shadow-control*
  (new 'static
       'shadow-control
       :settings
       (new 'static
            'shadow-settings
            :flags (shadow-flags shdf00 shdf03)
            :shadow-dir
            (new 'static 'vector :y -1.0 :w 614400.0)
            :bot-plane
            (new 'static 'plane :y 1.0 :w 4096.0)
            :top-plane
            (new 'static 'plane :y 1.0 :w -2048.0)
            :fade-dist 245760.0)))

(defpartgroup group-driller-lurker-drilling-debris
  :id 731
  :flags (use-local-clock)
  :bounds (static-bspherem 0 0 0 8)
  :parts
  ((sp-item 728 :fade-after (meters 80) :falloff-to (meters 80))
   (sp-item 2075 :fade-after (meters 60) :falloff-to (meters 60))
   (sp-item 2076 :fade-after (meters 60) :falloff-to (meters 60))
   (sp-item 2077 :fade-after (meters 40) :falloff-to (meters 40))))

(defpart 728
  :init-specs
  ((:texture (bigpuff effects))
   (:num 4.0)
   (:x (meters -0.5) (meters 1))
   (:y (meters -0.5) (meters 1))
   (:z (meters -0.5) (meters 1))
   (:scale-x (meters 1.5) (meters 1))
   (:rot-z (degrees 0) (degrees 360))
   (:scale-y :copy scale-x)
   (:r 64.0 32.0)
   (:g 64.0 32.0)
   (:b 64.0 32.0)
   (:a 32.0 64.0)
   (:vel-y (meters 0.026666667) (meters 0.026666667))
   (:scalevel-x (meters 0.006666667))
   (:rotvel-z (degrees -1.2) (degrees 1.2))
   (:scalevel-y :copy scalevel-x)
   (:fade-a -0.45714286)
   (:accel-y (meters 0.00066666666))
   (:friction 0.9)
   (:timer (seconds 0.7))
   (:flags (bit2 bit12 bit14))
   (:conerot-x (degrees 0) (degrees 180))
   (:conerot-y (degrees 0) (degrees 360))))

(defpart 2075
  :init-specs
  ((:texture (bigpuff effects))
   (:num 4.0)
   (:x (meters -0.5) (meters 1))
   (:y (meters -0.5) (meters 1))
   (:z (meters -0.5) (meters 1))
   (:scale-x (meters 0.5) (meters 0.25))
   (:rot-z (degrees 0) (degrees 360))
   (:scale-y :copy scale-x)
   (:r 64.0 32.0)
   (:g 64.0 32.0)
   (:b 64.0 32.0)
   (:a 32.0 32.0)
   (:vel-y (meters 0.053333335) (meters 0.10666667))
   (:scalevel-x (meters 0.006666667))
   (:rotvel-z (degrees -1.2) (degrees 1.2))
   (:scalevel-y :copy scalevel-x)
   (:fade-a -0.30476192)
   (:accel-y (meters 0.00066666666))
   (:friction 0.9)
   (:timer (seconds 0.7))
   (:flags (bit2 bit12 bit14))
   (:conerot-x (degrees 0) (degrees 180))
   (:conerot-y (degrees 0) (degrees 360))))

(defpart 2076
  :init-specs
  ((:texture (rockbit effects))
   (:num 4.0)
   (:x (meters -0.5) (meters 1))
   (:y (meters -0.5) (meters 1))
   (:z (meters -0.5) (meters 1))
   (:scale-x (meters 0.1) (meters 0.1))
   (:rot-z (degrees 0) (degrees 360))
   (:scale-y :copy scale-x)
   (:r 96.0 64.0)
   (:g 128.0 64.0)
   (:b 192.0 64.0)
   (:a 128.0)
   (:vel-y (meters 0.053333335) (meters 0.10666667))
   (:rotvel-z (degrees -1.2) (degrees 1.2))
   (:accel-y (meters -0.0033333334))
   (:friction 0.97)
   (:timer (seconds 1.5))
   (:flags (bit2 bit12 bit14))
   (:next-time (seconds 1.25))
   (:next-launcher 2078)
   (:conerot-x (degrees 0) (degrees 180))
   (:conerot-y (degrees 0) (degrees 360))))

(defpart 2078
  :init-specs ((:fade-a -1.7066667)))

(defpart 2077
  :init-specs
  ((:texture (rockbit effects))
   (:num 8.0 8.0)
   (:x (meters -0.5) (meters 1))
   (:y (meters -0.5) (meters 1))
   (:z (meters -0.5) (meters 1))
   (:scale-x (meters 0.05) (meters 0.15))
   (:rot-z (degrees 0) (degrees 360))
   (:scale-y :copy scale-x)
   (:r 96.0 64.0)
   (:g 128.0 64.0)
   (:b 192.0 64.0)
   (:a 64.0 64.0)
   (:vel-y (meters 0.053333335) (meters 0.10666667))
   (:rotvel-z (degrees -1.2) (degrees 1.2))
   (:accel-y (meters -0.0033333334))
   (:friction 0.97)
   (:timer (seconds 0.5))
   (:flags (bit2 bit12 bit14))
   (:next-time (seconds 0.017))
   (:next-launcher 2078)
   (:conerot-x (degrees 0) (degrees 180))
   (:conerot-y (degrees 0) (degrees 360))))

(defbehavior driller-lurker-default-event-handler driller-lurker ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (local-vars (sv-96 collide-shape-prim))
  (cond
    ((= arg2 'attack)
     (cond
       ((= (-> arg0 type) target)
        (let ((v1-3 (-> arg3 param 2)))
          (when (!= v1-3 (-> self player-attack-id))
            (set! (-> self player-attack-id) v1-3)
            (case (-> self mode)
              ((5)
               (let ((v1-5 *target*))
                 (when (!= (-> arg3 param 1) 'flop)
                   (let ((f0-4 (atan (- (-> v1-5 control trans x) (-> self root-overeride trans x))
                                     (- (-> v1-5 control trans z) (-> self root-overeride trans z)))))
                     (quaternion-axis-angle! (-> self root-overeride quat) 0.0 1.0 0.0 f0-4))))
               (go abandon-driller-lurker-die))
              (else
               (let ((s4-0 *target*)
                     (s2-0 #f)
                     (s3-0 #f))
                 (let* ((s1-0 (the-as touching-shapes-entry (-> arg3 param 0)))
                        (s0-0 (-> s1-0 head)))
                   (while s0-0
                     (set! sv-96 (get-touched-prim s0-0 (-> self root-overeride) s1-0))
                     (if (and (logtest? (-> (get-touched-prim s0-0 (-> s4-0 control) s1-0) prim-core action) (collide-action solid))
                              (logtest? (-> sv-96 prim-id) 1))
                       (set! s2-0 #t))
                     (if (logtest? (-> sv-96 prim-id) 2) (set! s3-0 #t))
                     (set! s0-0 (-> s0-0 next))))
                 (cond
                   ((or s2-0 (not s3-0))
                    (when (send-event arg0 'attack (-> arg3 param 0) (static-attack-info ((shove-up (meters 2)) (shove-back (meters 3)))))
                      (set! (-> self hit-player?) #t)
                      (set-time! (-> self hit-player-time))
                      (set-collide-offense (-> self root-overeride) 2 (collide-offense no-offense))
                      (let ((v1-39 (-> self mode))) (if (or (zero? v1-39) (= v1-39 1) (= v1-39 2)) (go abandon-driller-lurker-chase #t)))))
                   (s3-0
                    (when (!= (-> arg3 param 1) 'flop)
                      (let ((f0-11 (atan (- (-> s4-0 control trans x) (-> self root-overeride trans x))
                                         (- (-> s4-0 control trans z) (-> self root-overeride trans z)))))
                        (quaternion-axis-angle! (-> self root-overeride quat) 0.0 1.0 0.0 f0-11)))
                    (go abandon-driller-lurker-die)))))))))
       (else (go abandon-driller-lurker-die))))
    ((= arg2 'touch)
     (when (= (-> arg0 type) target)
       (when (send-event arg0 'attack (-> arg3 param 0) (static-attack-info ((shove-up (meters 2)) (shove-back (meters 3)))))
         (set! (-> self hit-player?) #t)
         (set-time! (-> self hit-player-time))
         (set-collide-offense (-> self root-overeride) 2 (collide-offense no-offense))
         (let ((v1-62 (-> self mode))) (if (or (zero? v1-62) (= v1-62 1) (= v1-62 2)) (go abandon-driller-lurker-chase #t))))))))

(defmethod abandon-driller-lurker-method-20 ((this abandon-driller-lurker) (arg0 symbol) (arg1 target))
  (let ((v1-1 (current-time)))
    (when (!= v1-1 (-> this last-update-time))
      (set! (-> this last-update-time) v1-1)
      (let* ((f0-0 (-> this path-speed))
             (f1-1 (seek f0-0 (-> this targ-path-speed) (* 12288.0 (seconds-per-frame)))))
        (set! (-> this path-speed) f1-1)
        (when (< 0.0 f1-1)
          (let* ((f0-5 (-> this path-u))
                 (f30-0 (* (-> this path-dir) f1-1 (seconds-per-frame)))
                 (s4-0 #t)
                 (f0-6 (+ f0-5 (* (/ (-> this path-units-per-meter) METER_LENGTH) f30-0))))
            (cond
              ((< f0-6 0.0)
               (set! s4-0 #f)
               (cond
                 (arg0 (set! f0-6 (- f0-6)) (set! (-> this path-dir) (- (-> this path-dir))) (set! (-> this path-speed) 0.0))
                 (else (set! f0-6 0.0) (set! (-> this path-speed) 0.0))))
              ((< 1.0 f0-6)
               (set! s4-0 #f)
               (cond
                 (arg0 (set! f0-6 (- 2.0 f0-6)) (set! (-> this path-dir) (- (-> this path-dir))) (set! (-> this path-speed) 0.0))
                 (else (set! f0-6 1.0) (set! (-> this path-speed) 0.0)))))
            (set! (-> this path-u) f0-6)
            (let ((s3-1 (new 'stack-no-clear 'vector)))
              (set! (-> s3-1 quad) (-> this root-overeride trans quad))
              (eval-path-curve! (-> this path) (-> this root-overeride trans) f0-6 'interp)
              (when s4-0
                (let ((f0-7 (vector-vector-xz-distance s3-1 (-> this root-overeride trans))))
                  #|
                    fix for higher framerate:

                    when the lurker changes directions, path-speed can get extremely close to 0
                    when this happens, the change in u on a frame may be extremely small

                    so the vector-vector-xz-distance is very small (because you didn't move much
                    on the path) and (set! (-> this path-units-per-meter) (* (/ (fabs f30-0) f0-7)
                    (-> this path-units-per-meter))) makes things blow up because that division isn't
                    accurate for tiny numbers
                  |#
                  (when (> f0-7 0.00001)
                    (set! (-> this path-units-per-meter) (* (/ (fabs f30-0) f0-7) (-> this path-units-per-meter))))))))))
      (let ((s4-1 (new 'stack-no-clear 'vector)))
        (path-control-method-14 (-> this path) s4-1 (-> this path-u))
        (let ((f0-13 (atan (-> s4-1 x) (-> s4-1 z))))
          (if (< (-> this path-dir) 0.0) (set! f0-13 (+ 32768.0 f0-13)))
          (set! (-> this path-ry) f0-13)))
      (case (-> this mode)
        ((4)
         (when *target*
           (let ((a0-13 (target-pos 0))
                 (v1-26 (new 'stack-no-clear 'vector)))
             (vector-! v1-26 a0-13 (-> this root-overeride trans))
             (let ((f0-16 (atan (-> v1-26 x) (-> v1-26 z))))
               (set! (-> this facing-ry) (deg-seek-smooth (-> this facing-ry) f0-16 (* 32768.0 (seconds-per-frame)) 0.25))))
           (when (< 16384.0 (fabs (deg- (-> this facing-ry) (-> this path-ry))))
             (set! (-> this path-dir) (- (-> this path-dir)))
             (+! (-> this path-ry) 32768.0))))
        (else
         (if (!= (-> this mode) 1)
           (set! (-> this facing-ry) (deg-seek-smooth (-> this facing-ry) (-> this path-ry) (* 32768.0 (seconds-per-frame)) 0.25)))))
      (quaternion-axis-angle! (-> this root-overeride quat) 0.0 1.0 0.0 (-> this facing-ry))
      (let ((f30-2 0.0))
        (when *target*
          (let ((f0-34 (vector-vector-xz-distance (target-pos 0) (-> this root-overeride trans))))
            (if (< f0-34 36864.0) (set! f30-2 (- 1.0 (* 0.00006510417 (fmax 0.0 (+ -21504.0 f0-34))))))))
        (let ((f28-1 (* 0.0001373291 (fmin 7281.778 (fabs (deg- (-> this path-ry) (-> this facing-ry)))))))
          (cond
            ((< 0.0 f30-2)
             (let ((s3-2 (new 'stack-no-clear 'vector)))
               (vector-! s3-2 (target-pos 0) (-> this root-overeride trans))
               (let* ((f1-27 (vector-x-angle s3-2))
                      (f1-29 (fmax 728.1778 (fmin 10194.489 f1-27)))
                      (f0-46 (* 0.000105637766 (+ -728.1778 f1-29)))
                      (f0-47 (lerp f28-1 f0-46 f30-2)))
                 (set! (-> this up-blend) (seek-with-smooth (-> this up-blend) f0-47 (* 8192.0 (seconds-per-frame)) 0.25 0.01)))))
            (else (set! (-> this up-blend) (seek-with-smooth (-> this up-blend) f28-1 (* 8192.0 (seconds-per-frame)) 0.125 0.01))))))
      (when (and arg1 *target*)
        (set-target! (-> this neck) (target-pos 5))
        (if *target*
          (look-at-enemy! (-> *target* neck) (the-as vector (-> this root-overeride root-prim prim-core)) 'attacking this)))
      (let ((f30-3 (-> this drill-speed)))
        (let ((v1-56 (-> this mode)))
          (cond
            ((or (= v1-56 2) (zero? v1-56)) (set! f30-3 (seek f30-3 72817.78 (* 372827.03 (seconds-per-frame)))))
            ((= v1-56 1) (set! f30-3 (seek f30-3 276707.56 (* 372827.03 (seconds-per-frame)))))
            ((or (= v1-56 3) (= v1-56 4))
             (set! f30-3
                   (if (time-elapsed? (-> this started-chasing-time) (seconds 2.25))
                     (seek f30-3 0.0 (* 600746.7 (seconds-per-frame)))
                     (seek f30-3 276707.56 (* 372827.03 (seconds-per-frame))))))
            ((= v1-56 5)
             (set! f30-3
                   (if (time-elapsed? (-> this started-chasing-time) (seconds 5.75))
                     (seek f30-3 276707.56 (* 372827.03 (seconds-per-frame)))
                     (seek f30-3 0.0 (* 600746.7 (seconds-per-frame))))))))
        (set! (-> this drill-speed) f30-3)
        (cond
          ((>= f30-3 36408.89)
           (update-trans! (-> this sound) (-> this root-overeride trans))
           (update! (-> this sound))
           (set! (-> this played-drill-sound?) #t))
          (else (when (-> this played-drill-sound?) (set! (-> this played-drill-sound?) #f) (stop! (-> this sound)))))
        (let ((f0-69 (+ (-> this drill-rz) (* f30-3 (seconds-per-frame)))))
          (set! (-> this drill-rz) (- f0-69 (* (the float (the int (/ f0-69 65536.0))) 65536.0)))))
      (let ((s5-2 (new 'stack-no-clear 'quaternion)))
        (quaternion-axis-angle! s5-2 0.0 0.0 1.0 (-> this drill-rz))
        (set-trs! (-> this drill) (the-as vector #f) s5-2 (the-as vector #f)))
      0))
  (when (and (-> this hit-player?)
             (or (not *target*)
                 (and (not (logtest? (-> *target* state-flags)
                                     (state-flags being-attacked invulnerable timed-invulnerable invuln-powerup do-not-notice dying)))
                      (time-elapsed? (-> this hit-player-time) (seconds 0.05)))))
    (set-collide-offense (-> this root-overeride) 2 (collide-offense touch))
    (set! (-> this hit-player?) #f)
    #f))

(defmethod abandon-driller-lurker-method-23 ((this abandon-driller-lurker))
  (let ((v1-1 (current-time)))
    (when (!= v1-1 (-> this last-player-path-u-time))
      (set! (-> this last-player-path-u-time) v1-1)
      (cond
        (*target*
         (let* ((s5-0 (-> this path))
                (s4-0 (method-of-object s5-0 path-control-method-20)))
           (target-pos 0)
           (set! (-> this player-path-u) (s4-0 s5-0))))
        (else (set! (-> this player-path-u) 0.0)))))
  (-> this player-path-u))

(defmethod abandon-driller-lurker-method-25 ((this abandon-driller-lurker))
  (when *target*
    (let* ((s5-0 (target-pos 0))
           (f0-1 (- (-> s5-0 y) (-> this root-overeride trans y))))
      (when (and (>= 32768.0 f0-1) (>= f0-1 -2048.0))
        (case (-> this mode)
          ((1) (if (>= 73728.0 (vector-vector-xz-distance (-> this root-overeride trans) s5-0)) (return #t)))
          (else
           (when (>= 102400.0 (vector-vector-xz-distance (-> this root-overeride trans) s5-0))
             (let ((f0-8 (atan (- (-> s5-0 x) (-> this root-overeride trans x)) (- (-> s5-0 z) (-> this root-overeride trans z)))))
               (if (>= 20024.889 (fabs (deg- f0-8 (-> this facing-ry)))) (return #t)))))))))
  #f)

(defmethod abandon-driller-lurker-method-26 ((this abandon-driller-lurker))
  (when *target*
    (let* ((a1-0 (target-pos 0))
           (f0-1 (- (-> a1-0 y) (-> this root-overeride trans y))))
      (if (and (< f0-1 40960.0) (< -10240.0 f0-1) (< (vector-vector-xz-distance (-> this root-overeride trans) a1-0) 143360.0))
        (return #f))))
  #t)

(defmethod abandon-driller-lurker-method-24 ((this abandon-driller-lurker))
  (when *target*
    (let* ((a1-0 (target-pos 0))
           (f0-1 (- (-> a1-0 y) (-> this root-overeride trans y))))
      (when (and (< f0-1 40960.0) (< -10240.0 f0-1))
        (let ((f0-2 (vector-vector-xz-distance (-> this root-overeride trans) a1-0)))
          (cond
            ((>= 17408.0 f0-2) (return #t))
            ((< f0-2 143360.0)
             (let ((f0-3 (abandon-driller-lurker-method-23 this))
                   (f1-5 (-> this path-u)))
               (if (>= (/ (-> this path-units-per-meter) 10) (fabs (- f0-3 f1-5))) (return #t)))))))))
  #f)

(defmethod abandon-driller-lurker-method-27 ((this abandon-driller-lurker))
  (let ((a2-0 (-> this node-list data 25 bone transform))
        (s5-0 (new 'stack-no-clear 'vector)))
    (set-vector! s5-0 0.0 0.0 8192.0 1.0)
    (vector-matrix*! s5-0 s5-0 a2-0)
    (vector-float*! s5-0 s5-0 (/ 1.0 (-> s5-0 w)))
    (spawn (-> this part) s5-0)))

(defstate abandon-driller-lurker-debug-play-anims (abandon-driller-lurker)
  :code
    (behavior ()
      0)
  :post transform-post)

(defstate abandon-driller-lurker-idle-drilling (abandon-driller-lurker)
  :event driller-lurker-default-event-handler
  :enter
    (behavior ()
      (set! (-> self mode) (the-as uint 1))
      (set! (-> self targ-path-speed) 0.0)
      (set! (-> self path-speed) 0.0)
      (shut-down! (-> self neck)))
  :exit
    (behavior ()
      (stop! (-> self sound2)))
  :trans
    (behavior ()
      (if (abandon-driller-lurker-method-25 self) (go abandon-driller-lurker-chase #t))
      (abandon-driller-lurker-method-20 self #t (the-as target #f)))
  :code
    (behavior ()
      (update-trans! (-> self sound2) (-> self root-overeride trans))
      (loop
        (set! (-> self timeout) (rand-vu-int-range 4 8))
        (ja-channel-push! 1 (seconds 0.2))
        (dotimes (gp-0 (-> self timeout))
          (let ((f30-0 (rand-vu-float-range 1.0 1.8)))
            (ja-no-eval :group! driller-lurker-idle-drilling-ja :num! (seek! max f30-0) :frame-num 0.0)
            (until (ja-done? 0)
              (update! (-> self sound2))
              (if (and (>= (ja-aframe-num 0) 7.0) (>= 13.0 (ja-aframe-num 0))) (abandon-driller-lurker-method-27 self))
              (suspend)
              (ja :num! (seek! max f30-0)))))
        (stop! (-> self sound2))
        (ja-channel-push! 1 (seconds 0.2))
        (if (zero? (rand-vu-int-count 2))
          (ja :group! driller-lurker-idle-look-left-ja :num! min)
          (ja :group! driller-lurker-idle-look-right-ja :num! min))
        (ja-no-eval :num! (seek!))
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek!)))))
  :post transform-post)

(defstate abandon-driller-lurker-patrol (abandon-driller-lurker)
  :event driller-lurker-default-event-handler
  :enter
    (behavior ()
      (set! (-> self mode) (the-as uint 2))
      (set-time! (-> self state-time))
      (set! (-> self timeout) (rand-vu-int-range 900 3600))
      (set! (-> self targ-path-speed) 15360.0)
      (if (>= 4096.0 (-> self path-speed)) (set! (-> self targ-path-speed) 15360.0))
      (shut-down! (-> self neck)))
  :trans
    (behavior ()
      (if (abandon-driller-lurker-method-25 self) (go abandon-driller-lurker-chase #t))
      (abandon-driller-lurker-method-20 self #t (the-as target #f)))
  :code
    (behavior ()
      (ja-channel-push! 2 (seconds 0.2))
      (ja :group! driller-lurker-walk-ja :num! min)
      (ja :chan 1 :group! driller-lurker-walk-up-ja :num! (chan 0) :frame-interp (-> self up-blend))
      (loop
        (suspend)
        (ja :num! (seek!))
        (if (= (ja-group-size) 2) (ja :chan 1 :num! (chan 0) :frame-interp (-> self up-blend)))
        (when (ja-done? 0)
          (if (and (time-elapsed? (-> self state-time) (-> self timeout))
                   (>= 546.13336 (fabs (deg- (-> self path-ry) (-> self facing-ry)))))
            (go abandon-driller-lurker-patrol-pause))
          (ja :num-func num-func-identity :frame-num 0.0))))
  :post transform-post)

(defstate abandon-driller-lurker-patrol-pause (abandon-driller-lurker)
  :event driller-lurker-default-event-handler
  :enter
    (behavior ()
      (set! (-> self mode) (the-as uint 2))
      (set! (-> self path-speed) 0.0)
      (set! (-> self targ-path-speed) 0.0)
      (shut-down! (-> self neck)))
  :trans
    (behavior ()
      (if (abandon-driller-lurker-method-25 self) (go abandon-driller-lurker-chase #t))
      (abandon-driller-lurker-method-20 self #t (the-as target #f)))
  :code
    (behavior ()
      (set! (-> self timeout) (rand-vu-int-range 2 4))
      (let ((s5-0 -1))
        (dotimes (gp-0 (-> self timeout))
          (let ((v1-0 (rand-vu-int-count 3)))
            (if (= v1-0 s5-0) (set! v1-0 (mod (+ v1-0 1) 3)))
            (set! s5-0 v1-0)
            (cond
              ((zero? v1-0)
               (if (not (ja-group? driller-lurker-idle-ja)) (ja-channel-push! 1 (seconds 0.2)))
               (ja :group! driller-lurker-idle-ja :num! min))
              ((= v1-0 1)
               (if (not (ja-group? driller-lurker-idle-look-left-ja)) (ja-channel-push! 1 (seconds 0.2)))
               (ja :group! driller-lurker-idle-look-left-ja :num! min))
              ((= v1-0 2)
               (if (not (ja-group? driller-lurker-idle-look-right-ja)) (ja-channel-push! 1 (seconds 0.2)))
               (ja :group! driller-lurker-idle-look-right-ja :num! min))))
          (ja-no-eval :num! (seek!))
          (until (ja-done? 0)
            (suspend)
            (ja :num! (seek!)))))
      (go abandon-driller-lurker-patrol))
  :post transform-post)

(defstate abandon-driller-lurker-chase (abandon-driller-lurker)
  :event driller-lurker-default-event-handler
  :enter
    (behavior ((arg0 symbol))
      (if arg0 (set-time! (-> self started-chasing-time)))
      (set! (-> self mode) (the-as uint 3))
      (set-time! (-> self state-time))
      (set! (-> self targ-path-speed) 23552.0))
  :trans
    (behavior ()
      (if (abandon-driller-lurker-method-24 self) (go abandon-driller-lurker-attack))
      (if (abandon-driller-lurker-method-26 self) (go abandon-driller-lurker-patrol))
      (if (time-elapsed? (-> self started-chasing-time) (seconds 3)) (go abandon-driller-lurker-jammed-standing))
      (let* ((gp-0 (-> self path))
             (s5-0 (method-of-object gp-0 path-control-method-20)))
        (target-pos 0)
        (let ((f0-1 (- (s5-0 gp-0) (-> self path-u))))
          (when (>= (fabs f0-1) (/ (-> self path-units-per-meter) 10))
            (cond
              ((< 0.0 f0-1) (when (< (-> self path-dir) 0.0) (set! (-> self path-dir) 1.0) (set! (-> self path-speed) 0.0)))
              (else (when (>= (-> self path-dir) 0.0) (set! (-> self path-dir) -1.0) (set! (-> self path-speed) 0.0)))))))
      (abandon-driller-lurker-method-20 self #f (the-as target #t)))
  :code
    (behavior ((arg0 symbol))
      (ja-channel-push! 2 (seconds 0.2))
      (ja :group! driller-lurker-run-ja :num! min)
      (ja :chan 1 :group! driller-lurker-run-up-ja :num! (chan 0) :frame-interp (-> self up-blend))
      (loop
        (suspend)
        (ja :num! (seek!))
        (if (= (ja-group-size) 2) (ja :chan 1 :num! (chan 0) :frame-interp (-> self up-blend)))
        (if (ja-done? 0) (ja :num-func num-func-identity :frame-num 0.0))))
  :post transform-post)

(defstate abandon-driller-lurker-attack (abandon-driller-lurker)
  :event driller-lurker-default-event-handler
  :enter
    (behavior ()
      (set! (-> self mode) (the-as uint 4))
      (set-time! (-> self state-time))
      (set! (-> self path-speed) 0.0)
      (set! (-> self targ-path-speed) 0.0))
  :trans
    (behavior ()
      (cond
        ((abandon-driller-lurker-method-24 self) (set-time! (-> self state-time)))
        (else (if (time-elapsed? (-> self state-time) (seconds 0.5)) (go abandon-driller-lurker-chase #f))))
      (if (time-elapsed? (-> self started-chasing-time) (seconds 3)) (go abandon-driller-lurker-jammed-standing))
      (abandon-driller-lurker-method-20 self #f (the-as target #t)))
  :code
    (behavior ()
      (ja-channel-push! 2 (seconds 0.2))
      (ja :group! driller-lurker-attack-ja :num! min)
      (ja :chan 1 :group! driller-lurker-attack-up-ja :num! (chan 0) :frame-interp (-> self up-blend))
      (loop
        (suspend)
        (ja :num! (seek!))
        (if (= (ja-group-size) 2) (ja :chan 1 :num! (chan 0) :frame-interp (-> self up-blend)))
        (if (ja-done? 0) (ja :num-func num-func-identity :frame-num 0.0))))
  :post transform-post)

(defstate abandon-driller-lurker-jammed-standing (abandon-driller-lurker)
  :event driller-lurker-default-event-handler
  :enter
    (behavior ()
      (set! (-> self mode) (the-as uint 5))
      (set! (-> self path-speed) 0.0)
      (set! (-> self targ-path-speed) 0.0)
      (shut-down! (-> self neck)))
  :trans
    (behavior ()
      (abandon-driller-lurker-method-20 self #f (the-as target #f)))
  :code
    (behavior ()
      (ja-channel-push! 1 (seconds 0.2))
      (ja-no-eval :group! driller-lurker-drill-jams-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!)))
      (set-time! (-> self started-chasing-time))
      (cond
        ;;(*target* (go driller-lurker-chase #f) (set! (-> self path-speed) 5888.0)) ;; temporarily removed due to crashing?
        (else (set! (-> self path-speed) 7680.0) (go abandon-driller-lurker-patrol))))
  :post transform-post)

(defstate abandon-driller-lurker-die (abandon-driller-lurker)
  :event process-drawable-death-event-handler
  :code
    (behavior ()
    ;; NEW: send event to puzzle master
      (let ((msg (new 'stack-no-clear 'event-message-block))) ;; code for driller in abandon
        (set! (-> msg from) self) ;; code for driller in abandon
        (set! (-> msg message) 'notify) ;; code for driller in abandon
        (set! (-> msg num-params) 2) ;; code for driller in abandon
        (set! (-> msg param 0) (the int (-> self driller-id))) ;; code for driller in abandon
        (set! (-> msg param 1) 1) ;; code for driller in abandon
        (send-event-function (-> (entity-actor-lookup (-> self entity) 'alt-actor 0) extra process) msg)) ;; code for driller in abandon
      (shut-down! (-> self neck))
      (logclear! (-> self mask) (process-mask actor-pause))
      (ja-channel-push! 1 (seconds 0.2))
      (clear-collide-with-as (-> self root-overeride))
      (ja-no-eval :group! driller-lurker-die-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!)))
      (send-event self 'death-end)
      (while (-> self child)
        (suspend))
      (cleanup-for-death self))
  :post ja-post)

(defmethod relocate ((this abandon-driller-lurker) (offset int))
  (if (nonzero? (-> this neck)) (&+! (-> this neck) offset))
  (if (nonzero? (-> this drill)) (&+! (-> this drill) offset))
  (if (nonzero? (-> this sound2)) (&+! (-> this sound2) offset))
  (call-parent-method this offset))

(defmethod deactivate ((this abandon-driller-lurker))
  (if (nonzero? (-> this sound2)) (stop! (-> this sound2)))
  ((method-of-type process-drawable deactivate) this)
  (none))

(defmethod init-from-entity! ((this abandon-driller-lurker) (arg0 entity-actor))
  (local-vars (sv-16 res-tag))
  (set! (-> this hit-player?) #f)
  (set! (-> this played-drill-sound?) #f)
  (set! (-> this hit-player-time) 0)
  (set! (-> this mode) (the-as uint 0))
  (set! (-> this drill-rz) 0.0)
  (set! (-> this drill-speed) 72817.78)
  (set! (-> this last-update-time) 0)
  (set! (-> this last-player-path-u-time) 0)
  (set! (-> this started-chasing-time) 0)
  (set! (-> this player-attack-id) (the-as uint 0))
  (set! (-> this ambient-drilling-u) -1.0)
  (logior! (-> this mask) (process-mask enemy))
  (let ((s4-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) default-collision-reaction)
    (set! (-> s4-0 no-reaction) (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 6) 0)))
      (set! (-> s3-0 prim-core collide-as) (collide-kind enemy))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core action) (collide-action solid attackable attackable-unused))
      (set! (-> s3-0 prim-core offense) (collide-offense normal-attack))
      (set-vector! (-> s3-0 local-sphere) 0.0 11264.0 0.0 22528.0)
      (set-root-prim! s4-0 s3-0)
      (let ((s2-0 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 2))))
        (set! (-> s2-0 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-0 collide-with) (collide-kind target))
        (set! (-> s2-0 prim-core action) (collide-action solid attackable attackable-unused))
        (set! (-> s2-0 prim-core offense) (collide-offense touch))
        (set-vector! (-> s2-0 local-sphere) 0.0 3276.8 0.0 4505.6)
        (append-prim s3-0 s2-0))
      (let ((s2-1 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 2))))
        (set! (-> s2-1 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-1 collide-with) (collide-kind target))
        (set! (-> s2-1 prim-core action) (collide-action solid attackable attackable-unused))
        (set! (-> s2-1 prim-core offense) (collide-offense touch))
        (set-vector! (-> s2-1 local-sphere) 0.0 7372.8 0.0 4505.6)
        (append-prim s3-0 s2-1))
      (let ((s2-2 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 2))))
        (set! (-> s2-2 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-2 collide-with) (collide-kind target))
        (set! (-> s2-2 prim-core action) (collide-action solid attackable attackable-unused))
        (set! (-> s2-2 prim-core offense) (collide-offense touch))
        (set-vector! (-> s2-2 local-sphere) 0.0 11468.8 0.0 4505.6)
        (append-prim s3-0 s2-2))
      (let ((s2-3 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 1))))
        (set! (-> s2-3 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-3 collide-with) (collide-kind target))
        (set! (-> s2-3 prim-core offense) (collide-offense normal-attack))
        (set! (-> s2-3 transform-index) 25)
        (set-vector! (-> s2-3 local-sphere) 0.0 0.0 4096.0 3276.8)
        (append-prim s3-0 s2-3))
      (let ((s2-4 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 1))))
        (set! (-> s2-4 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-4 collide-with) (collide-kind target))
        (set! (-> s2-4 prim-core offense) (collide-offense normal-attack))
        (set! (-> s2-4 transform-index) 25)
        (set-vector! (-> s2-4 local-sphere) 0.0 0.0 5734.4 3686.4)
        (append-prim s3-0 s2-4))
      (let ((s2-5 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 1))))
        (set! (-> s2-5 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-5 collide-with) (collide-kind target))
        (set! (-> s2-5 prim-core offense) (collide-offense normal-attack))
        (set! (-> s2-5 transform-index) 25)
        (set-vector! (-> s2-5 local-sphere) 0.0 0.0 9420.8 2457.6)
        (append-prim s3-0 s2-5)))
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> this root-overeride) s4-0))
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton this *abandon-driller-lurker-sg* '())
  (set! (-> this path) (new 'process 'curve-control this 'path -1000000000.0))
  (logior! (-> this path flags) (path-control-flag display draw-line draw-point draw-text))
  (if (< (-> this path curve num-cverts) 2) (go process-drawable-art-error "bad path"))
  (set! (-> this fact) (new 'process 'fact-info-enemy this (pickup-type eco-pill-random) (-> *FACT-bank* default-pill-inc)))
  (set! (-> this draw shadow-ctrl) *driller-lurker-shadow-control*)
  (set! (-> this sound)
        (new 'process 'ambient-sound (static-sound-spec "drill-idle" :fo-max 40) (-> this root-overeride trans)))
  (set! (-> this sound2)
        (new 'process 'ambient-sound (static-sound-spec "drill-idle2" :fo-max 60) (-> this root-overeride trans)))
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 731) this))
  (let ((f0-34 (path-distance (-> this path)))) (set! (-> this path-units-per-meter) (/ 4096.0 f0-34)))
  (set! (-> this path-dir) 1.0)
  (set! (-> this path-u) 0.0)
  (set! (-> this path-speed) 15360.0)
  (set! (-> this targ-path-speed) 15360.0)
  (set! (-> this up-blend) 0.0)
  (set! sv-16 (new 'static 'res-tag))
  (let ((v1-91 (res-lump-data arg0 'abandon-driller-lurker (pointer float) :tag-ptr (the-as (pointer res-tag) (new 'stack-no-clear 'vector)))))
    (when v1-91
      (set! (-> this path-u) (fmax 0.0 (fmin 1.0 (-> v1-91 0))))
      (if (< (-> v1-91 1) 0.0) (set! (-> this path-dir) -1.0))
      (let ((f0-45 (-> v1-91 2)))
        (when (!= f0-45 12345.0)
          (let ((f30-0 (* 182.04445 f0-45)))
            (set! (-> this ambient-drilling-u) (-> this path-u))
            (quaternion-axis-angle! (-> this root-overeride quat) 0.0 1.0 0.0 f30-0)
            (set! (-> this facing-ry) f30-0))))))
  (eval-path-curve! (-> this path) (-> this root-overeride trans) (-> this path-u) 'interp)
  (let ((s5-1 (new 'stack-no-clear 'vector)))
    (path-control-method-14 (-> this path) s5-1 (-> this path-u))
    (let ((f0-51 (atan (-> s5-1 x) (-> s5-1 z))))
      (if (< (-> this path-dir) 0.0) (set! f0-51 (+ 32768.0 f0-51)))
      (set! (-> this path-ry) f0-51)
      (if (< (-> this ambient-drilling-u) 0.0) (set! (-> this facing-ry) f0-51))))
  (let ((v1-103 (new 'process 'joint-mod (joint-mod-handler-mode reset) this 6)))
    (set! (-> this neck) v1-103)
    (set-vector! (-> this neck twist-max) 8192.0 8192.0 0.0 1.0)
    (set! (-> v1-103 up) (the-as uint 1))
    (set! (-> v1-103 nose) (the-as uint 2))
    (set! (-> v1-103 ear) (the-as uint 0))
    (set! (-> v1-103 max-dist) 102400.0)
    (set! (-> v1-103 ignore-angle) 16384.0))
  (let ((raw-id (res-lump-value (-> this entity) 'extra-id uint128 ;; driller code for abandon
                                :default (the-as uint128 -1)))) ;; driller code for abandon
    (if (>= (the-as int raw-id) 0) ;; driller code for abandon
        (set! (-> this driller-id) (the uint (the-as int raw-id))) ;; driller code for abandon
        (set! (-> this driller-id) 0))) ;; driller code for abandon
  (set! (-> this drill) (new 'process 'joint-mod (joint-mod-handler-mode joint-set*) this 38))
  (transform-post)
  (create-connection! *cavecrystal-light-control*
                      this
                      (-> this entity)
                      (the-as (function object object object object object) cavecrystal-light-control-default-callback)
                      -1
                      8192.0)
  (when (not (task-complete? *game-info* (game-task abandon-drillers)))
  (if (>= (-> this ambient-drilling-u) 0.0) (go abandon-driller-lurker-idle-drilling) (go abandon-driller-lurker-patrol)))
  (none))


;; driller master code for driller abandon task;;
(deftype driller-puzzle-master (process-drawable)
  ((killed-mask uint)
   (required-mask uint))
  (:states
   driller-master-idle))

(defstate driller-master-idle (driller-puzzle-master)
  :event
    (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
      (case message
        (('notify)
         (let ((bit (the int (-> block param 0)))
               (active? (the int (-> block param 1))))
           (when (!= active? 0)
             (logior! (-> self killed-mask) (ash 1 bit)))
           (format 0 "[DRILLER MASTER] Kill bit ~D, mask now ~X~%" bit (-> self killed-mask))
           (when (= (-> self killed-mask) (-> self required-mask))
             (format 0 "[DRILLER MASTER] All drillers killed! Triggering reward~%")
             (birth-pickup-at-point ;; spawns powercell at jak
   (-> *target* control trans)
   (pickup-type fuel-cell)
   (the float (-> self entity extra perm task))
   #f
   self
   (the-as fact-info #f))
             
             ))
         #t)
        ((#t) #f))) ;; spawns powercell at jak ^^^
  :code
    (behavior ()
      (loop (suspend)))
  :post #f)

(defmethod init-from-entity! ((this driller-puzzle-master) (e entity-actor))
  (set! (-> this root) (new 'process 'trsqv))
  (process-drawable-from-entity! this e)
  ;; for 10 drillers, required-mask = (2^10 - 1) = #x3FF
  (set! (-> this required-mask) #x3FF)
  (set! (-> this killed-mask) 0)
  (go driller-master-idle)
  (none))

